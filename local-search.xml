<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Generics, Inheritance, and Subtypes</title>
    <link href="/2024/03/18/Generics-Inheritance-and-Subtypes/"/>
    <url>/2024/03/18/Generics-Inheritance-and-Subtypes/</url>
    
    <content type="html"><![CDATA[<p>As you already know, it is possible to assign an object of one type to an object of another type provided that the types are compatible. For example, you can assign an Integer to an Object, since Object is one of Integer’s supertypes:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">someObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Integer</span> <span class="hljs-variable">someInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br>someObject = someInteger;   <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>在面向对象的术语中，这称为“是”关系。由于 Integer 是 Object 的一种，因此允许赋值。但 Integer 也是 Number 的一种，因此以下代码也是有效的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">(Number n)</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br>someMethod(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>));   <span class="hljs-comment">// OK</span><br>someMethod(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">10.1</span>));   <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>The same is also true with generics. You can perform a generic type invocation, passing Number as its type argument, and any subsequent invocation of add will be allowed if the argument is compatible with Number:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Box&lt;Number&gt; box = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>&lt;Number&gt;();<br>box.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>));   <span class="hljs-comment">// OK</span><br>box.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">10.1</span>));  <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>Now consider the following method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">boxTest</span><span class="hljs-params">(Box&lt;Number&gt; n)</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>What type of argument does it accept? By looking at its signature, you can see that it accepts a single argument whose type is <code>Box&lt;Number&gt;</code>. But what does that mean? Are you allowed to pass in <code>Box&lt;Integer&gt;</code> or <code>Box&lt;Double&gt;</code>, as you might expect? The answer is “no”, because <code>Box&lt;Integer&gt;</code> and <code>Box&lt;Double&gt;</code> are not subtypes of <code>Box&lt;Number&gt;</code>.</p><p><img src="https://docs.oracle.com/javase/tutorial/figures/java/generics-subtypeRelationship.gif" alt="Generics, Inheritance, and Subtypes"></p><blockquote><p>Given two concrete types A and B (for example, Number and Integer), <code>MyClass&lt;A&gt;</code> has no relationship to <code>MyClass&lt;B&gt;</code>, regardless of whether or not A and B are related. The common parent of <code>MyClass&lt;A&gt;</code> and <code>MyClass&lt;B&gt;</code> is Object.</p></blockquote><h2 id="Generic-Classes-and-Subtyping"><a href="#Generic-Classes-and-Subtyping" class="headerlink" title="Generic Classes and Subtyping"></a>Generic Classes and Subtyping</h2><p>You can subtype a generic class or interface by extending or implementing it. The relationship between the type parameters of one class or interface and the type parameters of another are determined by the extends and implements clauses.</p><p>Using the Collections classes as an example, <code>ArrayList&lt;E&gt;</code> implements <code>List&lt;E&gt;</code>, and <code>List&lt;E&gt;</code> extends <code>Collection&lt;E&gt;</code>. So <code>ArrayList&lt;String&gt;</code> is a subtype of <code>List&lt;String&gt;</code>, which is a subtype of <code>Collection&lt;String&gt;</code>. So long as you do not vary the type argument, the subtyping relationship is preserved between the types.</p><p><img src="https://docs.oracle.com/javase/tutorial/figures/java/generics-sampleHierarchy.gif" alt="A sample Collections hierarchy"></p><p>Now imagine we want to define our own list interface, PayloadList, that associates an optional value of generic type <code>P</code> with each element. Its declaration might look like:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PayloadList</span>&lt;E,P&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPayload</span><span class="hljs-params">(<span class="hljs-type">int</span> index, P val)</span>;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>The following parameterizations of PayloadList are subtypes of <code>List&lt;String&gt;</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">PayloadList&lt;String,String&gt;<br>PayloadList&lt;String,Integer&gt;<br>PayloadList&lt;String,Exception&gt;<br></code></pre></td></tr></table></figure><p><img src="https://docs.oracle.com/javase/tutorial/figures/java/generics-payloadListHierarchy.gif" alt="A sample PayloadList hierarchy"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java Generics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bounded Type Parameters</title>
    <link href="/2024/03/18/Bounded-Type-Parameters/"/>
    <url>/2024/03/18/Bounded-Type-Parameters/</url>
    
    <content type="html"><![CDATA[<p>There may be times when you want to restrict the types that can be used as type arguments in a parameterized type. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. This is what bounded type parameters are for.</p><p>To declare a bounded type parameter, list the type parameter’s name, followed by the extends keyword, followed by its upper bound. Note that, in this context, extends is used in a general sense to mean either “extends” (as in classes) or “implements” (as in interfaces).</p><h2 id="Multiple-Bounds"><a href="#Multiple-Bounds" class="headerlink" title="Multiple Bounds"></a>Multiple Bounds</h2><p>类型参数可以具有多个边界：</p><p><code>&lt;T extends B1 &amp; B2 &amp; B3&gt;</code></p><p>A type variable with multiple bounds is a subtype of all the types listed in the bound. If one of the bounds is a class, it must be specified first. For example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Class A &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">C</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &amp; B &amp; C&gt; &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><h2 id="Generic-Methods-and-Bounded-Type-Parameters"><a href="#Generic-Methods-and-Bounded-Type-Parameters" class="headerlink" title="Generic Methods and Bounded Type Parameters"></a>Generic Methods and Bounded Type Parameters</h2><p>Bounded type parameters are key to the implementation of generic algorithms. Consider the following method that counts the number of elements in an array T[] that are greater than a specified element elem.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-type">int</span> <span class="hljs-title function_">countGreaterThan</span><span class="hljs-params">(T[] anArray, T elem)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (T e : anArray)<br>        <span class="hljs-keyword">if</span> (e &gt; elem)  <span class="hljs-comment">// compiler error</span><br>            ++count;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p>The implementation of the method is straightforward, but it does not compile because the greater than operator (&gt;) applies only to primitive types such as short, int, double, long, float, byte, and char. You cannot use the &gt; operator to compare objects. To fix the problem, use a type parameter bounded by the <code>Comparable&lt;T&gt;</code> interface:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>The resulting code will be:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt; <span class="hljs-type">int</span> <span class="hljs-title function_">countGreaterThan</span><span class="hljs-params">(T[] anArray, T elem)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (T e : anArray)<br>        <span class="hljs-keyword">if</span> (e.compareTo(elem) &gt; <span class="hljs-number">0</span>)<br>            ++count;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java Generics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Generic Methods</title>
    <link href="/2024/03/18/Generic-Methods/"/>
    <url>/2024/03/18/Generic-Methods/</url>
    
    <content type="html"><![CDATA[<p>Generic methods are methods that introduce their own type parameters. This is similar to declaring a generic type, but the type parameter’s scope is limited to the method where it is declared. Static and non-static generic methods are allowed, as well as generic class constructors.</p><p>The syntax for a generic method includes a list of type parameters, inside angle brackets, which appears before the method’s return type. For static generic methods, the type parameter section must appear before the method’s return type.</p><p>The Util class includes a generic method, compare, which compares two <code>Pair</code> objects:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Util</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2)</span> &#123;<br>        <span class="hljs-keyword">return</span> p1.getKey().equals(p2.getKey()) &amp;&amp;<br>               p1.getValue().equals(p2.getValue());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;K, V&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> K key;<br>    <span class="hljs-keyword">private</span> V value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setKey</span><span class="hljs-params">(K key)</span> &#123; <span class="hljs-built_in">this</span>.key = key; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(V value)</span> &#123; <span class="hljs-built_in">this</span>.value = value; &#125;<br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>   &#123; <span class="hljs-keyword">return</span> key; &#125;<br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> value; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The complete syntax for invoking this method would be:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;Integer, String&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>);<br>Pair&lt;Integer, String&gt; p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;pear&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">same</span> <span class="hljs-operator">=</span> Util.&lt;Integer, String&gt;compare(p1, p2);<br></code></pre></td></tr></table></figure><p>The type has been explicitly provided, as shown in bold. Generally, this can be left out and the compiler will infer the type that is needed:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;Integer, String&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>);<br>Pair&lt;Integer, String&gt; p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;pear&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">same</span> <span class="hljs-operator">=</span> Util.compare(p1, p2);<br></code></pre></td></tr></table></figure><p>This feature, known as <strong>type inference（类型推断）</strong>, allows you to invoke a generic method as an ordinary method, without specifying a type between angle brackets.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java Generics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Generic Types</title>
    <link href="/2024/03/18/Generic-Types/"/>
    <url>/2024/03/18/Generic-Types/</url>
    
    <content type="html"><![CDATA[<p>A generic type is a generic class or interface that is parameterized over types. The following Box class will be modified to demonstrate the concept.</p><h2 id="A-Simple-Box-Class"><a href="#A-Simple-Box-Class" class="headerlink" title="A Simple Box Class"></a>A Simple Box Class</h2><p>Begin by examining a non-generic Box class that operates on objects of any type. It needs only to provide two methods: set, which adds an object to the box, and get, which retrieves it:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> &#123;<br>    <span class="hljs-keyword">private</span> Object object;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(Object object)</span> &#123; <span class="hljs-built_in">this</span>.object = object; &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> object; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Since its methods accept or return an Object, you are free to pass in whatever you want, provided that it is not one of the primitive types. There is no way to verify, at compile time, how the class is used. One part of the code may place an Integer in the box and expect to get Integers out of it, while another part of the code may mistakenly pass in a String, resulting in a runtime error.</p><h2 id="A-Generic-Version-of-the-Box-Class"><a href="#A-Generic-Version-of-the-Box-Class" class="headerlink" title="A Generic Version of the Box Class"></a>A Generic Version of the Box Class</h2><p>泛型类按以下格式定义：</p><p><code>class name&lt;T1, T2, ..., Tn&gt; &#123; /* ... */ &#125;</code></p><p>The type parameter section, delimited by angle brackets (&lt;&gt;), follows the class name. It specifies the type parameters (also called type variables) T1, T2, …, and Tn.</p><p>将泛型参数应用于 <code>Box</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Generic version of the Box class.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt; the type of the value being boxed</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// T stands for &quot;Type&quot;</span><br>    <span class="hljs-keyword">private</span> T t;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T t)</span> &#123; <span class="hljs-built_in">this</span>.t = t; &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> t; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>As you can see, all occurrences of Object are replaced by T. A type variable can be any <strong>non-primitive</strong> type you specify: any class type, any interface type, any array type, or even another type variable.</p><p>同样的技术可用于创建通用接口。</p><h2 id="Type-Parameter-Naming-Conventions"><a href="#Type-Parameter-Naming-Conventions" class="headerlink" title="Type Parameter Naming Conventions"></a>Type Parameter Naming Conventions</h2><p>按照约定，类型参数名称是单个大写字母。</p><p>最常用的类型参数名称是：</p><ul><li>E - Element (used extensively by the Java CollectionsFramework)</li><li>E - Element</li><li>K - Key</li><li>N - Number</li><li>T - Type</li><li>V - Value</li></ul><h2 id="Invoking-and-Instantiating-a-Generic-Type"><a href="#Invoking-and-Instantiating-a-Generic-Type" class="headerlink" title="Invoking and Instantiating a Generic Type"></a>Invoking and Instantiating a Generic Type</h2><p>要从代码中引用泛型 <code>Box</code> 类，必须执行泛型类型调用，它将 <code>T</code> 替换为一些具体值，例如 <code>Integer</code> ：</p><p><code>Box&lt;Integer&gt; integerBox;</code></p><p>可以将泛型类型调用视为与普通方法调用类似，但不是将参数传递给方法，而是将类型参数（在本例中为 Integer ）传递给 Box 类本身。</p><p>Type Parameter and Type Argument Terminology: Many developers use the terms “type parameter” and “type argument” interchangeably, but these terms are not the same. When coding, one provides type arguments in order to create a parameterized type. Therefore, the <code>T</code> in <code>Foo&lt;T&gt;</code> is a type parameter and the <code>String</code> in <code>Foo&lt;String&gt; f</code> is a type argument.</p><p>Like any other variable declaration, this code does not actually create a new Box object. It simply declares that integerBox will hold a reference to a “Box of Integer”, which is how <code>Box&lt;Integer&gt;</code> is read.</p><p>An invocation of a generic type is generally known as a parameterized type.</p><p>To instantiate this class, use the new keyword, as usual, but place <code>&lt;Integer&gt;</code> between the class name and the parenthesis:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Box&lt;Integer&gt; integerBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><h2 id="The-Diamond"><a href="#The-Diamond" class="headerlink" title="The Diamond"></a>The Diamond</h2><p>In Java SE 7 and later, you can replace the type arguments required to invoke the constructor of a generic class with an empty set of type arguments (&lt;&gt;) as long as the compiler can determine, or infer, the type arguments from the context. This pair of angle brackets, &lt;&gt;, is informally called the diamond. For example, you can create an instance of <code>Box&lt;Integer&gt;</code> with the following statement:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Box&lt;Integer&gt; integerBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h2 id="Multiple-Type-Parameters"><a href="#Multiple-Type-Parameters" class="headerlink" title="Multiple Type Parameters"></a>Multiple Type Parameters</h2><p>如前所述，泛型类可以有多个类型参数（type parameters）。例如，通用 <code>OrderedPair</code> 类，它实现通用 <code>Pair</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Pair</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderedPair</span>&lt;K, V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Pair</span>&lt;K, V&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> K key;<br>    <span class="hljs-keyword">private</span> V value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderedPair</span><span class="hljs-params">(K key, V value)</span> &#123;<br>      <span class="hljs-built_in">this</span>.key = key;<br>      <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> key; &#125;<br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> value; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下语句创建 <code>OrderedPair</code> 类的两个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String, Integer&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderedPair</span>&lt;&gt;(<span class="hljs-string">&quot;Even&quot;</span>, <span class="hljs-number">8</span>);<br>Pair&lt;String, String&gt;  p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderedPair</span>&lt;&gt;(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure><p>代码 <code>new OrderedPair&lt;String, Integer&gt;</code> 将 <code>K</code> 实例化为 <code>String</code> ，将 <code>V</code> 实例化为 <code>Integer</code> 。因此，<code>OrderedPair</code> 构造函数的参数类型分别为 <code>String</code> 和 <code>Integer</code> 。</p><p>要创建通用接口，遵循与创建通用类相同的约定。</p><h2 id="Parameterized-Types"><a href="#Parameterized-Types" class="headerlink" title="Parameterized Types"></a>Parameterized Types</h2><p>You can also substitute a type parameter (that is, <code>K</code> or <code>V</code>) with a parameterized type (that is, <code>List&lt;String&gt;</code>). For example, using the <code>OrderedPair&lt;K, V&gt;</code> example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">OrderedPair&lt;String, Box&lt;Integer&gt;&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderedPair</span>&lt;&gt;(<span class="hljs-string">&quot;primes&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>&lt;Integer&gt;(...));<br></code></pre></td></tr></table></figure><h2 id="Raw-Types"><a href="#Raw-Types" class="headerlink" title="Raw Types"></a>Raw Types</h2><p>A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T t)</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>To create a parameterized type of <code>Box&lt;T&gt;</code>, you supply an actual type argument for the formal type parameter <code>T</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Box&lt;Integer&gt; intBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>If the actual type argument is omitted, you create a raw type of <code>Box&lt;T&gt;</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Box</span> <span class="hljs-variable">rawBox</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>();<br></code></pre></td></tr></table></figure><p>Therefore, Box is the raw type of the generic type <code>Box&lt;T&gt;</code>. However, a non-generic class or interface type is not a raw type.</p><p>Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior — a <code>Box</code> gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Box&lt;String&gt; stringBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>&lt;&gt;();<br><span class="hljs-type">Box</span> <span class="hljs-variable">rawBox</span> <span class="hljs-operator">=</span> stringBox;<br></code></pre></td></tr></table></figure><p>But if you assign a raw type to a parameterized type, you get a warning:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Box</span> <span class="hljs-variable">rawBox</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>();           <span class="hljs-comment">// rawBox is a raw type of Box&lt;T&gt;</span><br>Box&lt;Integer&gt; intBox = rawBox;     <span class="hljs-comment">// warning: unchecked conversion</span><br></code></pre></td></tr></table></figure><p>You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Box&lt;String&gt; stringBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>&lt;&gt;();<br><span class="hljs-type">Box</span> <span class="hljs-variable">rawBox</span> <span class="hljs-operator">=</span> stringBox;<br>rawBox.set(<span class="hljs-number">8</span>);  <span class="hljs-comment">// warning: unchecked invocation to set(T)</span><br></code></pre></td></tr></table></figure><p>The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java Generics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Why Use Generics?</title>
    <link href="/2024/03/18/Why-Use-Generics/"/>
    <url>/2024/03/18/Why-Use-Generics/</url>
    
    <content type="html"><![CDATA[<p>简而言之，泛型使类型（类和接口）能够在定义类、接口和方法时成为参数。与方法声明中使用的更熟悉的形式参数非常相似，类型参数提供了一种通过不同输入重复使用相同代码的方法。区别在于形式参数的输入是值，而类型参数的输入是类型。</p><p>使用泛型的代码比非泛型代码有很多好处：</p><ul><li><p>编译时更强的类型检查。</p><p>Java 编译器对泛型代码应用强类型检查，如果代码违反类型安全，则会发出错误。修复编译时错误比修复运行时错误更容易，后者很难发现。</p></li><li><p>消除类型转换</p><p>以下没有泛型的代码片段需要强制转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>list.add(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String) list.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>当重写为使用泛型时，代码不需要转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);   <span class="hljs-comment">// no cast</span><br></code></pre></td></tr></table></figure></li><li><p>使程序员能够实现通用算法。</p><p>通过使用泛型，程序员可以实现适用于不同类型集合的泛型算法，可以自定义，并且类型安全且更易于阅读。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java Generics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Annotations</title>
    <link href="/2024/03/18/Java-Annotations/"/>
    <url>/2024/03/18/Java-Annotations/</url>
    
    <content type="html"><![CDATA[<p>Annotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate.</p><p>Annotations have a number of uses, among them:</p><ul><li>Information for the compiler — Annotations can be used by the compiler to detect errors or suppress warnings.</li><li>Compile-time and deployment-time processing — Software tools can process annotation information to generate code, XML files, and so forth.</li><li>Runtime processing — Some annotations are available to be examined at runtime.</li></ul><h2 id="Annotations-Basics"><a href="#Annotations-Basics" class="headerlink" title="Annotations Basics"></a>Annotations Basics</h2><h3 id="The-Format-of-an-Annotation"><a href="#The-Format-of-an-Annotation" class="headerlink" title="The Format of an Annotation"></a>The Format of an Annotation</h3><p>最简单的注解形式如下所示：</p><p><code>@Entity</code></p><p>at 符号字符 ( @ ) 向编译器指示后面的内容是注解。</p><p>注解可以包含元素，这些元素可以命名或未命名，并且这些元素有值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Author(</span><br><span class="hljs-meta">   name = &quot;Benjamin Franklin&quot;,</span><br><span class="hljs-meta">   date = &quot;3/27/2003&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">@注解(value = <span class="hljs-string">&quot;unchecked&quot;</span>)<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>如果只有一个名为 value 的元素，则可以省略该名称，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">@注解(<span class="hljs-string">&quot;unchecked&quot;</span>)<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>如果注解没有元素，则可以省略括号，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">mySuperMethod</span><span class="hljs-params">()</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>也可以在同一个声明上使用多个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Author(name = &quot;Jane Doe&quot;)</span><br><span class="hljs-meta">@EBook</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>如果声明的注解是相同的类型，则这称为重复注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Author(name = &quot;Jane Doe&quot;)</span><br><span class="hljs-meta">@Author(name = &quot;John Smith&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><blockquote><p>从 Java SE 8 版本开始支持可重复注解（Repeating Annotations）。</p></blockquote><p>注解类型可以是 Java SE API 的 java.lang 或 java.lang.annotation 包中定义的类型之一。在前面的示例中， Override 和 注解 是预定义的 Java 注解。也可以定义自己的注解类型。</p><h3 id="Where-Annotations-Can-Be-Used"><a href="#Where-Annotations-Can-Be-Used" class="headerlink" title="Where Annotations Can Be Used"></a>Where Annotations Can Be Used</h3><p>注解可以应用于声明：类、字段、方法和其他程序元素的声明。当在声明中使用时，按照惯例，每个注解通常出现在自己的行上。</p><p>从 Java SE 8 版本开始，注解也可以应用于类型的使用。</p><ul><li><p>Class instance creation expression:</p><p><code>new @Interned MyObject();</code></p></li><li><p>Type cast:</p><p><code>myString = (@NonNull String) str;</code></p></li><li><p>implements clause:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnmodifiableList</span>&lt;T&gt; implements<br><span class="hljs-meta">@Readonly</span> List&lt;<span class="hljs-meta">@Readonly</span> T&gt; &#123; ... &#125;<br></code></pre></td></tr></table></figure></li><li><p>Thrown exception declaration:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">monitorTemperature</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span><br>      <span class="hljs-meta">@Critical</span> TemperatureException &#123; ... &#125;<br></code></pre></td></tr></table></figure></li></ul><p>这种形式的注解称为类型注解。</p><h2 id="Declaring-an-Annotation-Type"><a href="#Declaring-an-Annotation-Type" class="headerlink" title="Declaring an Annotation Type"></a>Declaring an Annotation Type</h2><p>许多注解取代了代码中的注释。</p><p>Suppose that a software group traditionally starts the body of every class with comments providing important information:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generation3List</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Generation2List</span> &#123;<br><br>   <span class="hljs-comment">// Author: John Doe</span><br>   <span class="hljs-comment">// Date: 3/17/2002</span><br>   <span class="hljs-comment">// Current revision: 6</span><br>   <span class="hljs-comment">// Last modified: 4/12/2004</span><br>   <span class="hljs-comment">// By: Jane Doe</span><br>   <span class="hljs-comment">// Reviewers: Alice, Bill, Cindy</span><br><br>   <span class="hljs-comment">// class code goes here</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>To add this same metadata with an annotation, you must first define the annotation type.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@interface</span> ClassPreamble &#123;<br>   String <span class="hljs-title function_">author</span><span class="hljs-params">()</span>;<br>   String <span class="hljs-title function_">date</span><span class="hljs-params">()</span>;<br>   <span class="hljs-type">int</span> <span class="hljs-title function_">currentRevision</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>;<br>   String <span class="hljs-title function_">lastModified</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;N/A&quot;</span>;<br>   String <span class="hljs-title function_">lastModifiedBy</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;N/A&quot;</span>;<br>   <span class="hljs-comment">// Note use of array</span><br>   String[] reviewers();<br>&#125;<br></code></pre></td></tr></table></figure><p>The body of the previous annotation definition contains annotation type element declarations, which look a lot like methods. Note that they can define optional default values.</p><p>After the annotation type is defined, you can use annotations of that type, with the values filled in, like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ClassPreamble</span> (<br>   author = <span class="hljs-string">&quot;John Doe&quot;</span>,<br>   date = <span class="hljs-string">&quot;3/17/2002&quot;</span>,<br>   currentRevision = <span class="hljs-number">6</span>,<br>   lastModified = <span class="hljs-string">&quot;4/12/2004&quot;</span>,<br>   lastModifiedBy = <span class="hljs-string">&quot;Jane Doe&quot;</span>,<br>   <span class="hljs-comment">// Note array notation</span><br>   reviewers = &#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Cindy&quot;</span>&#125;<br>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generation3List</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Generation2List</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Predefined-Annotation-Types"><a href="#Predefined-Annotation-Types" class="headerlink" title="Predefined Annotation Types"></a>Predefined Annotation Types</h2><p>Java SE API 中预定义了一组注解类型。一些注解类型由 Java 编译器使用，一些注解类型适用于其他注解。</p><h3 id="Annotation-Types-Used-by-the-Java-Language"><a href="#Annotation-Types-Used-by-the-Java-Language" class="headerlink" title="Annotation Types Used by the Java Language"></a>Annotation Types Used by the Java Language</h3><p>java.lang 中定义的预定义注解类型是 <code>@Deprecated</code> 、 <code>@Override</code> 和 <code>@注解</code> 。</p><p><code>@Deprecated</code> 注解表示标记的元素已被弃用，不应再使用。每当程序使用带有 <code>@Deprecated</code> 注解的方法、类或字段时，编译器都会生成警告。当某个元素被弃用时，还应该使用 Javadoc @deprecated 标记对其进行记录，如以下示例所示。在 Javadoc 注释和注解中使用 at 符号 ( @ ) 并非巧合：它们在概念上是相关的。另请注意，Javadoc 标记以小写 d 开头，注解以大写 D 开头。</p><p><code>@Override</code> 注解通知编译器该元素将覆盖超类中声明的元素。</p><p>虽然重写方法时不需要使用此注解，但它有助于防止错误。如果标有 <code>@Override</code> 的方法无法正确重写其超类之一中的方法，编译器会生成错误。</p><p><code>@SuppressWarnings</code> 注解告诉编译器抑制否则会生成的特定警告。在以下示例中，使用了不推荐（<code>@Deprecated</code>）使用的方法，编译器通常会生成警告。然而，在这种情况下，注解会导致警告被抑制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// use a deprecated method and tell</span><br><span class="hljs-comment">// compiler not to generate a warning</span><br><span class="hljs-meta">@SuppressWarnings(&quot;deprecation&quot;)</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useDeprecatedMethod</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-comment">// deprecation warning</span><br>     <span class="hljs-comment">// - suppressed</span><br>     objectOne.deprecatedMethod();<br> &#125;<br></code></pre></td></tr></table></figure><p>每个编译器警告都属于一个类别。 Java 语言规范列出了两个类别： deprecation 和 unchecked 。当与泛型出现之前编写的遗留代码交互时，可能会出现 unchecked 警告。要抑制多个类别的警告，使用以下语法：</p><p><code>@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;)</code></p><p><code>@SafeVarargs</code> 注解应用于方法或构造函数时，断言代码不会对其 varargs 参数执行潜在的不安全操作。使用此注解类型时，将抑制与 varargs 使用相关的未经检查的警告。</p><p>Java SE 8 中引入的 @FunctionalInterface @FunctionalInterface 注解表明类型声明旨在成为 Java 语言规范所定义的函数式接口。</p><h3 id="Annotations-That-Apply-to-Other-Annotations"><a href="#Annotations-That-Apply-to-Other-Annotations" class="headerlink" title="Annotations That Apply to Other Annotations"></a>Annotations That Apply to Other Annotations</h3><p>应用于其它注解的注解被称为元注解（meta-annotations）。java.lang.annotation 中定义了多种元注解类型。</p><p><code>@Retention</code> 注解指定了标记的注解如何存储（保留的生命周期）：</p><ul><li><p><code>RetentionPolicy.SOURCE</code> – 标记的注解仅保留在源代码级别，并被编译器忽略。</p></li><li><p><code>RetentionPolicy.CLASS</code> – 标记的注解在编译时由编译器保留，但被 Java 虚拟机 (JVM) 忽略。</p></li><li><p><code>RetentionPolicy.RUNTIME</code> – 标记的注解由 JVM 保留，以便运行时环境可以通过反射机制使用。</p></li></ul><p><code>@Documented</code> 注解指示每当使用指定注解时，应使用 Javadoc 工具记录这些元素。</p><p><code>@Target</code> 注解标记了另一个注解，以限制该注解可以应用于哪种 Java 元素。目标注解指定以下元素类型之一作为其值：</p><ul><li><code>ElementType.ANNOTATION_TYPE</code> can be applied to an annotation type.</li><li><code>ElementType.CONSTRUCTOR</code> can be applied to a constructor.</li><li><code>ElementType.FIELD</code> can be applied to a field or property.</li><li><code>ElementType.LOCAL_VARIABLE</code> can be applied to a local variable.</li><li><code>ElementType.METHOD</code> can be applied to a method-level annotation.</li><li><code>ElementType.PACKAGE</code> can be applied to a package declaration.</li><li><code>ElementType.PARAMETER</code> can be applied to the parameters of a method.</li><li><code>ElementType.TYPE</code> can be applied to any element of a class.</li></ul><p><code>@Inherited</code> 注解表示该注解类型可以从超类继承。 （默认情况下并非如此。）</p><p><code>@Repeatable</code> 注解是 Java SE 8 中引入的，表示标记的注解可以多次应用于同一声明或类型使用。</p><h2 id="Repeating-Annotations"><a href="#Repeating-Annotations" class="headerlink" title="Repeating Annotations"></a>Repeating Annotations</h2><p>例如，正在编写代码来使用计时器服务，该服务能够在给定时间或按特定计划运行方法，类似于 UNIX cron 服务。现在，想要设置一个计时器来在每月的最后一天和每个星期五晚上 11:00 运行方法 doPeriodicCleanup 。要设置计时器运行，请创建 <code>@Schedule</code> 注解并将其应用到 doPeriodicCleanup 方法两次。第一次使用指定该月的最后一天，第二次指定星期五晚上 11 点，如以下代码示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Schedule(dayOfMonth=&quot;last&quot;)</span><br><span class="hljs-meta">@Schedule(dayOfWeek=&quot;Fri&quot;, hour=&quot;23&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPeriodicCleanup</span><span class="hljs-params">()</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>出于兼容性原因，重复注解存储在 Java 编译器自动生成的容器注解中。为了让编译器执行此操作，代码中需要两个声明。</p><h3 id="Step-1-Declare-a-Repeatable-Annotation-Type"><a href="#Step-1-Declare-a-Repeatable-Annotation-Type" class="headerlink" title="Step 1: Declare a Repeatable Annotation Type"></a>Step 1: Declare a Repeatable Annotation Type</h3><p>注解类型必须使用 <code>@Repeatable</code> 元注解进行标记。以下示例定义了自定义 <code>@Schedule</code> 可重复注解类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.Repeatable;<br><br><span class="hljs-meta">@Repeatable(Schedules.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Schedule &#123;<br>  String <span class="hljs-title function_">dayOfMonth</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;first&quot;</span>;<br>  String <span class="hljs-title function_">dayOfWeek</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;Mon&quot;</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-title function_">hour</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">12</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>括号中的 <code>@Repeatable</code> 元注解的值是 Java 编译器生成的用于存储重复注解的容器注解的类型。在此示例中，包含注解类型（containing annotation type）为 <code>Schedules</code> ，因此重复的 <code>@Schedule</code> 注解存储在 <code>@Schedules</code> 注释中。</p><p>将相同的注解应用于声明而不首先声明它是可重复的会导致编译时错误。</p><h3 id="Step-2-Declare-the-Containing-Annotation-Type"><a href="#Step-2-Declare-the-Containing-Annotation-Type" class="headerlink" title="Step 2: Declare the Containing Annotation Type"></a>Step 2: Declare the Containing Annotation Type</h3><p>包含注解类型必须具有数组类型的 value 元素。数组类型的元素类型必须是可重复的注解类型。包含注解类型的 Schedules 声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Schedules &#123;<br>    Schedule[] value();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java Annotations</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vocabulary 01</title>
    <link href="/2024/03/12/Vocabulary-01/"/>
    <url>/2024/03/12/Vocabulary-01/</url>
    
    <content type="html"><![CDATA[<ol><li><p>short-sighted &#x2F;ˌʃɔːrtˈsaɪ.t̬ɪd&#x2F;</p><p>近视的</p><p>She has to wear glasses because she’s very short-sighted.</p><p>My brother has good eyesight whereas I am a little shortsighted.</p><p>目光短浅的，没有远见的</p><p>It’s very short-sighted of the government not to invest in technological research.</p></li><li><p>condemn</p><p>（通常指出于道义而）谴责，指责</p><p>The terrorist action has been condemned as an act of barbarism and cowardice.</p><p>人们谴责这一恐怖行径是野蛮和懦弱的行为。</p><p>The film was condemned for its sexism.</p><p>这部影片被指责带有性别歧视。</p></li><li><p>barbarism&#x2F;ˈbɑːr.bɚ.ɪ.zəm&#x2F;</p><p>extremely cruel and unpleasant behaviour</p><p>He witnessed some appalling acts of barbarism during the war.</p><p>他亲眼目睹了战争期间发生的一些骇人听闻的野蛮行为。</p></li><li><p>cowardice&#x2F;ˈkaʊ.ɚ.dɪs&#x2F;</p><p>Cowardice prevented me from doing what I knew I should do.</p><p>懦弱使我无法做我知道自己应该做的事情。</p><p>You can accuse me of cowardice, but I still wouldn’t fight in a war.</p><p>你可以指责我懦弱，但我仍然不会去打仗。</p></li><li><p>sexism&#x2F;ˈsek.sɪ.zəm&#x2F;</p><p>The university has been accused of sexism because it has so few women professors.</p><p>这所大学被指控存在性别歧视，因为女教授极少。</p></li><li><p>cruel</p><p>Don’t tease him about his weight - it’s cruel.</p><p>别拿他的体重开玩笑——这样太刻薄了。</p><p>Children can be very cruel to each other.</p><p>小孩相互之间会很残忍。</p><p>His death was a cruel blow.</p><p>他的死是个无情的打击。</p></li><li><p>intentionally | purposely | deliberately | on purpose</p><p>I didn’t ignore her intentionally - I just didn’t recognize her.</p><p>我没有故意无视她——我只是没认出她。</p><p>She was being intentionally unpleasant.</p><p>她是故意耍态度的。</p><p>The trial has been purposely delayed.</p><p>审判被有意延期了。</p><p>I purposely avoid making train journeys during the rush hour.</p><p>我有意避开在高峰时间乘火车。</p><p>I’m sure he says these things deliberately to annoy me.</p><p>我敢肯定他是故意说这些来气我的。</p><p>I didn’t do it on purpose - it was an accident.</p><p>我不是故意这样做的，是个意外。</p></li><li><p>behaviour</p><p>the way that someone behaves</p><p>Her behaviour is often appalling.</p><p>她的行为举止常常糟糕之极。<br>He was notorious for his violent and threatening behaviour.</p><p>他因暴力和威胁行为而声名狼藉。</p><p>（在某种环境或条件下的）特定行为</p><p>His research involved the study of instinctive behaviour in birds.</p><p>他的研究是关于鸟类本能行为的。</p><p>These behaviours can be observed among many children who have lost a parent or other loved one.</p><p>这类行为可能出现在失去了父母或亲人的儿童身上。</p></li><li><p>purpose</p><p><strong>意图，目的，原因</strong></p><p>The purpose of the research is to try to find out more about the causes of the disease.</p><p>研究的目的是试图进一步探寻引起这种疾病的原因。</p><p>His only purpose in life seems to be to enjoy himself.</p><p>Her main&#x2F;primary purpose in suing the newspaper for libel was to clear her name.</p><p>她控告这家报纸诽谤的主要目的是澄清她的清白。</p><p>I came to Brighton for&#x2F;with the express purpose of seeing you.</p><p>She had the operation entirely for cosmetic purposes.</p><p>她做这次手术纯粹是为了美容。</p><p>a multi-purpose kitchen knife</p><p>I can see no useful purpose in continuing this conversation.</p><p>我看不到继续这次谈话有任何益处。</p><p>All my efforts were to no purpose (&#x3D; failed).</p><p>我所有的努力都付诸东流了。</p><p>He gave her a sum of money which she used to good purpose (&#x3D; well).</p><p>他给她的那笔钱她都用在了该用的地方。</p><p><strong>决心，意志</strong></p><p>I’ve always admired her for her strength of purpose.</p><p>我一直佩服她意志坚定。</p><p>Parenthood would give him a sense of purpose.</p><p>身为人父会让他变得有意志。</p></li><li><p>parenthood&#x2F;ˈper.ənt.hʊd&#x2F;</p><p>The prospect of parenthood filled her with horror.</p><p>将为人母使她内心充满了恐惧。</p></li><li><p>involve&#x2F;ɪnˈvɑːlv&#x2F;</p><p>Research involving the use of biological warfare agents will be used for defensive purposes.</p><p>The operation involves putting a small tube into your heart.</p><p>The second accident involved two cars and a lorry.<br>第二起事故涉及到两辆小汽车和一辆大卡车。</p><p>I prefer teaching methods that actively involve students in learning.</p><p>我更喜欢能让学生主动参与学习的教学法。</p><p>She’s been involved with animal rights for many years.</p><p>她多年来一直参与保护动物权益的活动。</p></li><li><p>lorry | truck</p><p>an articulated&#x2F;ɑːrˈtɪk.jə.leɪ.t̬ɪd&#x2F; lorry</p><p>铰链式卡车</p><p>a long-distance lorry driver</p><p>长途货车司机</p><p>The road was completely blocked by an overturned truck.</p><p>道路完全被翻倒的卡车堵住了。</p></li><li><p>completely | totally | wholly | entirely</p><p>I agree with you completely.</p><p>She’s completely mad.</p><p>He’d completely changed - I didn’t recognize him.</p><p>他彻底变样了——我当时没认出来。</p><p>The company is run almost entirely by middle-aged men.</p><p>管理这个公司的几乎都是中年男性。</p></li><li><p>overturn</p><p>The car skidded&#x2F;skɪd&#x2F; off the road, hit a tree and overturned.</p><p>汽车滑出道路，撞到树上后翻了。</p><p>The intruder had overturned some of the furniture in the house.</p><p>入室窃贼翻动了屋子里的一些家具。</p><p>The Court of Appeal overturned the earlier decision.</p><p>上诉法庭推翻了早先作出的裁决。</p></li><li><p>middle-aged</p><p>They’re a middle-aged couple, with grown-up children.</p><p>他们是一对中年夫妇，孩子们都已成年。</p></li><li><p>instinctive</p><p>an instinctive reaction</p><p>本能反应</p></li><li><p>extremely | exceedingly | super</p><p>They played extremely well.</p><p>他们演奏得非常精彩。</p><p>She’s extremely beautiful.</p></li><li><p>prevent</p><p>to stop something from happening or someone from doing something</p><p>Label your suitcases to prevent confusion.</p><p>在你的手提箱上贴上标签以防弄混。</p><p>His disability prevents him (from) driving.</p></li><li><p>disability&#x2F;ˌdɪs.əˈbɪl.ə.t̬i&#x2F;</p><p>a physical&#x2F;learning disability</p><p>身体残疾／学习障碍</p><p>She is deaf, but refuses to let her disability prevent her from doing what she wants to do.</p><p>Trying to change attitudes to disability is an uphill struggle.</p><p>改变对待残疾的态度是一项艰巨的工作。</p></li><li><p>uphill&#x2F;ˌʌpˈhɪl&#x2F; | downhill&#x2F;ˌdaʊnˈhɪl&#x2F;</p><p>an uphill climb</p><p>向上的攀爬</p><p>running uphill</p><p>往山上跑</p><p>It’ll be an uphill struggle to get the new proposals accepted.</p><p>要让新的提案获得通过会很艰难。</p><p>It’s so much easier running downhill!</p><p>跑下山去容易多了！</p><p>The route is all downhill from here to the finishing line.</p><p>这条路线从这里到终点都是下坡。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vocabulary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024 年目标</title>
    <link href="/2024/03/11/2024-%E5%B9%B4%E7%9B%AE%E6%A0%87/"/>
    <url>/2024/03/11/2024-%E5%B9%B4%E7%9B%AE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<ul><li>把工作做好，提高编程技术</li><li>体重到 80 kg，变胖或者变壮一点</li><li>阅读 3~5 本书籍</li><li>尽量多打打网球，希望 1~2 周能打一次</li><li>精进英语，尤其是口语和听力</li><li>坚持写博客文章</li><li>尽量早睡早起</li><li>有时间多去南京的景点玩玩</li></ul>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Schedule</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript for…in Loop</title>
    <link href="/2024/03/06/JavaScript-for%E2%80%A6in-Loop/"/>
    <url>/2024/03/06/JavaScript-for%E2%80%A6in-Loop/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction-to-JavaScript-for…in-loop"><a href="#Introduction-to-JavaScript-for…in-loop" class="headerlink" title="Introduction to JavaScript for…in loop"></a>Introduction to JavaScript for…in loop</h2><p>for…in 循环遍历由对象字符串作为键的可枚举属性。注意，属性可以通过字符串（string）或符号（symbol）作为键。</p><p>当属性的内部可枚举（enumerable）标志设置为 true 时，该属性是可枚举的。</p><p>当通过简单赋值或属性初始值设定项创建属性时，可枚举标志默认为 true：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">object.<span class="hljs-property">propertyName</span> = value;<br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">propertyName</span>: value,<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>for…in 循环的语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> propertyName <span class="hljs-keyword">in</span> object) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>for…in 允许访问对象的每个可迭代属性和值，而无需知道属性的具体名称。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Doe&#x27;</span>,<br>  <span class="hljs-attr">ssn</span>: <span class="hljs-string">&#x27;299-24-2351&#x27;</span>,<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">in</span> person) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prop + <span class="hljs-string">&#x27;:&#x27;</span> + person[prop])<br>&#125;<br><span class="hljs-attr">firstName</span>: <span class="hljs-title class_">John</span><br><span class="hljs-attr">lastName</span>: <span class="hljs-title class_">Doe</span><br><span class="hljs-attr">ssn</span>: <span class="hljs-number">299</span> - <span class="hljs-number">24</span> - <span class="hljs-number">2351</span><br></code></pre></td></tr></table></figure><h2 id="The-for-in-loop-Inheritance"><a href="#The-for-in-loop-Inheritance" class="headerlink" title="The for...in loop &amp; Inheritance"></a>The <code>for...in</code> loop &amp; Inheritance</h2><p>When you loop over the properties of an object that inherits from another object, the <code>for...in</code> statement goes up in the prototype chain and enumerates inherited properties.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> decoration = &#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span>,<br>&#125;<br><span class="hljs-keyword">var</span> circle = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(decoration)<br>circle.<span class="hljs-property">radius</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">in</span> circle) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prop)<br>&#125;<br>radius<br>color<br></code></pre></td></tr></table></figure><p>The <code>circle</code> object has its own prototype that references the <code>decoration</code> object. Therefore, the <code>for...in</code> loop displays the properties of the <code>circle</code> object and its prototype.</p><p>如果只想枚举对象自己的属性，可以使用 hasOwnProperty() 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">in</span> circle) &#123;<br>  <span class="hljs-keyword">if</span> (circle.<span class="hljs-title function_">hasOwnProperty</span>(prop)) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prop)<br>  &#125;<br>&#125;<br>radius<br></code></pre></td></tr></table></figure><h2 id="The-for…in-loop-and-Array"><a href="#The-for…in-loop-and-Array" class="headerlink" title="The for…in loop and Array"></a>The for…in loop and Array</h2><p>最好不要使用 for…in 来迭代数组，特别是当数组元素的顺序很重要时。</p><p>下面的例子可以完美地工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> items = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br><span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">in</span> items) &#123;<br>  total += items[item]<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(total) <span class="hljs-comment">// 60</span><br></code></pre></td></tr></table></figure><p>但是，有人可能会在其库中设置内置数组类型的属性，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">foo</span> = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>因此，for…in 将无法正常工作。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// somewhere else</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">foo</span> = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">const</span> items = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];<br><span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> items) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123; prop, <span class="hljs-attr">value</span>: items[prop] &#125;);<br>  total += items[prop];<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(total);<br>&#123; <span class="hljs-attr">prop</span>: <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">10</span> &#125;<br>&#123; <span class="hljs-attr">prop</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">20</span> &#125;<br>&#123; <span class="hljs-attr">prop</span>: <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">30</span> &#125;<br>&#123; <span class="hljs-attr">prop</span>: <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">100</span> &#125;<br><span class="hljs-number">160</span><br></code></pre></td></tr></table></figure><p>另一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = []<br><span class="hljs-comment">// set the third element to 3, other elements are `undefined`</span><br>arr[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i])<br>&#125;<br><span class="hljs-comment">// 输出显示了数组的三个元素，这是正确的：</span><br><span class="hljs-literal">undefined</span><br><span class="hljs-literal">undefined</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>但是，for…in 循环忽略前两个元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> arr) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[key])<br>&#125;<br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript for...in</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript Object Properties</title>
    <link href="/2024/03/06/JavaScript-Object-Properties/"/>
    <url>/2024/03/06/JavaScript-Object-Properties/</url>
    
    <content type="html"><![CDATA[<h2 id="Object-Property-types"><a href="#Object-Property-types" class="headerlink" title="Object Property types"></a>Object Property types</h2><p>JavaScript specifies the characteristics of properties of objects via internal <strong>attributes</strong> surrounded by the two pairs of square brackets, e.g., <code>[[Enumerable]]</code>.</p><p>对象有两种类型的属性：数据属性（data properties）和访问器属性（accessor properties）。</p><h3 id="Data-properties"><a href="#Data-properties" class="headerlink" title="Data properties"></a>Data properties</h3><p>A data property contains a single location for a data value. A data property has four attributes(PropertyDescriptor):</p><ul><li><p>[[Configurarable]] – determines whether a property can be redefined or removed via delete operator.</p><p><strong>可配置性（Configurable）</strong>：指示属性是否可删除和是否可修改属性的特性。如果为 <code>true</code>，则属性可以被删除，属性的特性（包括 <code>writable</code>、<code>enumerable</code> 和 <code>configurable</code>）可以修改；如果为 <code>false</code>，则属性不可被删除，属性的特性不可被修改。</p></li><li><p>[[Enumerable]] – indicates if a property can be returned in the for…in loop.</p></li><li><p>[[Writable]] – specifies that the value of a property can be changed.</p></li><li><p>[[Value]] – contains the actual value of a property.</p></li></ul><p>默认情况下，直接在对象上定义的所有属性的 [[Configurable]] 、 [[Enumerable]] 和 [[Writable]] 属性设置为 true。 [[Value]] 属性的默认值为 undefined。</p><p>例如，以下创建一个具有两个属性 firstName 和 lastName 的 person 对象，并将 configurable、enumerable 和 writable attributes 设置为 true，并将它们的值分别设置为 “John” 和 “Doe”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Doe&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>To change any attribute of a property, use the <code>Object.defineProperty()</code> method.</p><p>Object.defineProperty() 方法接受三个参数：</p><ul><li>An object.</li><li>A property name of the object.</li><li>A property descriptor object that has four properties: <code>configurable</code>, <code>enumerable</code>, <code>writable</code>, and <code>value</code>.</li></ul><p>如果使用 Object.defineProperty() 方法定义对象的属性，除非另有指定，否则 [[Configurable]]、[[Enumerable]] 和 [[Writable]] 的默认值将设置为 false。</p><p>以下示例创建一个具有 Age 属性的 person 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;&#125;<br>person.<span class="hljs-property">age</span> = <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p>由于 [[Configurable]] 属性的默认值设置为 true，因此可以通过删除运算符将其删除：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">delete</span> person.<span class="hljs-property">age</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>以下示例创建一个 person 对象并使用 Object.defineProperty() 方法向其添加 ssn 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">let</span> person = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(person, <span class="hljs-string">&#x27;ssn&#x27;</span>, &#123;<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;012-38-9119&#x27;</span><br>&#125;);<br><span class="hljs-keyword">delete</span> person.<span class="hljs-property">ssn</span>;<br><span class="hljs-title class_">TypeError</span>: <span class="hljs-title class_">Cannot</span> <span class="hljs-keyword">delete</span> property <span class="hljs-string">&#x27;ssn&#x27;</span> <span class="hljs-keyword">of</span> #&lt;<span class="hljs-title class_">Object</span>&gt;<br></code></pre></td></tr></table></figure><p>在此示例中，configurable 属性设置为 false。因此，删除 ssn 属性会导致错误。</p><p>此外，一旦将属性定义为 non-configurable，就无法将其更改为 configurable。</p><p>默认情况下，对象上定义的所有属性的 enumerable 属性都是 true。这意味着可以使用 for…in 循环迭代所有对象属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;&#125;<br>person.<span class="hljs-property">age</span> = <span class="hljs-number">25</span><br>person.<span class="hljs-property">ssn</span> = <span class="hljs-string">&#x27;012-38-9119&#x27;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> property <span class="hljs-keyword">in</span> person) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(property)<br>&#125;<br>age<br>ssn<br></code></pre></td></tr></table></figure><p>以下通过将 enumerable 属性设置为 false 使 ssn 属性不可枚举。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;&#125;<br>person.<span class="hljs-property">age</span> = <span class="hljs-number">25</span><br>person.<span class="hljs-property">ssn</span> = <span class="hljs-string">&#x27;012-38-9119&#x27;</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(person, <span class="hljs-string">&#x27;ssn&#x27;</span>, &#123;<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br>&#125;)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> person) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prop)<br>&#125;<br>age<br></code></pre></td></tr></table></figure><h3 id="Accessor-properties"><a href="#Accessor-properties" class="headerlink" title="Accessor properties"></a>Accessor properties</h3><p>访问器属性是使用 getter 和 setter 函数定义的属性，它们并不存储数据值，而是在读取或设置属性时调用相关的函数。</p><p>Similar to data properties, accessor properties also have <code>[[Configurable]]</code> and <code>[[Enumerable]]</code> attributes.</p><p><strong>但访问器属性具有 [[Get]] 和 [[Set]]，而不是 [[Value]] 和 [[Writable]]。</strong></p><p>当从访问器属性读取数据时，会自动调用 [[Get]] 函数以返回值。 [[Get]] 函数的默认返回值是 undefined。</p><p>如果将值分配给访问器属性，则会自动调用 [[Set]] 函数。</p><p>要定义访问器属性，<strong>必须</strong>使用 Object.defineProperty() 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Doe&#x27;</span>,<br>&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(person, <span class="hljs-string">&#x27;fullName&#x27;</span>, &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">let</span> parts = value.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">if</span> (parts.<span class="hljs-property">length</span> == <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = parts[<span class="hljs-number">0</span>]<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = parts[<span class="hljs-number">1</span>]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Invalid name format&#x27;</span><br>    &#125;<br>  &#125;,<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">fullName</span>) <span class="hljs-comment">// &#x27;John Doe&#x27;</span><br></code></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li>首先，定义包含两个属性的 person 对象：firstName 和 lastName。</li><li>然后，将 fullName 属性作为访问器属性添加到 person 对象。</li></ul><p>在 fullname 访问器属性中：</p><ul><li>[[Get]] 返回由 firstName、空格和 lastName 连接而成的全名。</li><li>[[Set]] 方法按空格分割参数，并分配名称相应部分的 firstName 和 lastName 属性。</li><li>如果 fullName 的格式不正确，即名字、空格和姓氏，则会抛出错误。</li></ul><h2 id="Define-multiple-properties-Object-defineProperties"><a href="#Define-multiple-properties-Object-defineProperties" class="headerlink" title="Define multiple properties: Object.defineProperties()"></a>Define multiple properties: Object.defineProperties()</h2><p>在 ES5 中，可以使用 Object.defineProperties() 方法在单个语句中定义多个属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> product = &#123;&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(product, &#123;<br>  <span class="hljs-attr">name</span>: &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Smartphone&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">price</span>: &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">799</span>,<br>  &#125;,<br>  <span class="hljs-attr">tax</span>: &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">0.1</span>,<br>  &#125;,<br>  <span class="hljs-attr">netPrice</span>: &#123;<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> * (<span class="hljs-number">1</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">tax</span>)<br>    &#125;,<br>  &#125;,<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>  <span class="hljs-string">&#x27;The net price of a &#x27;</span> +<br>    product.<span class="hljs-property">name</span> +<br>    <span class="hljs-string">&#x27; is &#x27;</span> +<br>    product.<span class="hljs-property">netPrice</span>.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>) +<br>    <span class="hljs-string">&#x27; USD&#x27;</span><br>)<br><span class="hljs-comment">// The net price of a Smartphone is 878.90 USD</span><br></code></pre></td></tr></table></figure><p>在此示例中，我们为 product 对象定义了三个数据属性：name、price 和 tax 以及一个访问器属性 netPrice。</p><h2 id="JavaScript-object-property-descriptor"><a href="#JavaScript-object-property-descriptor" class="headerlink" title="JavaScript object property descriptor"></a>JavaScript object property descriptor</h2><p>Object.getOwnPropertyDescriptor() 方法允许获取属性的描述符对象。 Object.getOwnPropertyDescriptor() 方法采用两个参数：</p><ol><li>An object</li><li>A property of the object</li></ol><p>It returns a descriptor object that describes a property. The descriptor object has four properties: configurable, enumerable, writable, and value.</p><p>以下示例获取上一示例中 product 对象的 name 和 netPrice 属性的描述符对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(product, <span class="hljs-string">&#x27;name&#x27;</span>)<br><span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span><br><span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span><br><span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Smartphone&#x27;</span><br><span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(product, <span class="hljs-string">&#x27;netPrice&#x27;</span>)<br><span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span><br><span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span><br><span class="hljs-attr">get</span>: ƒ()<br><span class="hljs-attr">set</span>: <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript Object</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript this Keyword</title>
    <link href="/2024/03/06/JavaScript-this-Keyword/"/>
    <url>/2024/03/06/JavaScript-this-Keyword/</url>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中，可以在全局和函数上下文中使用 this 关键字。此外，this 关键字的行为在严格模式和非严格模式之间变化。</p><h2 id="What-is-this-keyword"><a href="#What-is-this-keyword" class="headerlink" title="What is this keyword"></a>What is this keyword</h2><p>this 在不同的上下文中引用不同的对象。</p><p>假设有一个对象 counter，它有一个方法 next()。当调用 next() 方法时，就可以访问 this 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> counter = &#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">next</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ++<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span><br>  &#125;,<br>&#125;<br><br>counter.<span class="hljs-title function_">next</span>()<br></code></pre></td></tr></table></figure><p>在 next() 函数中， this 引用 counter 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">counter.<span class="hljs-title function_">next</span>()<br></code></pre></td></tr></table></figure><p>next() 是一个函数，它是 counter 对象的属性。因此，在 next() 函数内部， this 引用了 counter 对象。</p><h2 id="Global-context"><a href="#Global-context" class="headerlink" title="Global context"></a>Global context</h2><p>在全局上下文中，this 引用全局对象，即 Web 浏览器上的 window 或 Node.js 上的 global。</p><p>此行为在严格模式和非严格模式下都是一致的。这是网络浏览器上的输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === <span class="hljs-variable language_">window</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如果在全局上下文中为该对象分配属性，JavaScript 会将该属性添加到全局对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;Red&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">color</span>) <span class="hljs-comment">// &#x27;Red&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="Function-context"><a href="#Function-context" class="headerlink" title="Function context"></a>Function context</h2><p>在 JavaScript 中，可以通过以下方式调用函数：</p><ul><li>Function invocation</li><li>Method invocation</li><li>Constructor invocation</li><li>Indirect invocation</li></ul><p>每个函数调用都定义其自己的上下文。因此， this 的行为有所不同。</p><h3 id="Simple-function-invocation"><a href="#Simple-function-invocation" class="headerlink" title="Simple function invocation"></a>Simple function invocation</h3><p>在非严格模式下，函数调用时 this 引用全局对象，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === <span class="hljs-variable language_">window</span>) <span class="hljs-comment">// true</span><br>&#125;<br><br><span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p>当调用 show() 函数时， this 引用全局对象，该对象在 Web 浏览器中是 window ，在 Node.js 中是 global 。</p><p>调用 show() 函数与以下内容相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p>在严格模式下，JavaScript 将函数内的 this 设置为 <code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// true</span><br>&#125;<br><span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p>注意，严格模式自 ECMAScript 5.1 起就可用。严格模式适用于函数和嵌套函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-string">&#x27;use strict&#x27;</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// true</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">display</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// true</span><br>  &#125;<br>  <span class="hljs-title function_">display</span>()<br>&#125;<br><span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><h3 id="Method-invocation"><a href="#Method-invocation" class="headerlink" title="Method invocation"></a>Method invocation</h3><p>当调用对象的方法时，JavaScript 将 this 设置为拥有该方法的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> car = &#123;<br>  <span class="hljs-attr">brand</span>: <span class="hljs-string">&#x27;Honda&#x27;</span>,<br>  <span class="hljs-attr">getBrand</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span><br>  &#125;,<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(car.<span class="hljs-title function_">getBrand</span>()) <span class="hljs-comment">// Honda</span><br></code></pre></td></tr></table></figure><p>在此示例中，getBrand() 方法中的 this 对象引用了 car 对象。</p><p>由于方法是对象的属性值，因此可以将其存储在变量中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> brand = car.<span class="hljs-property">getBrand</span><br></code></pre></td></tr></table></figure><p>然后通过变量调用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">brand</span>()) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>你会得到 undefined 而不是“Honda”，因为当你调用一个方法而不指定其对象时，JavaScript 在非严格模式下将其设置为全局对象，在严格模式下将其设置为 undefined。</p><p>要解决此问题，可以使用 Function.prototype 对象的 bind() 方法。 bind() 方法创建一个新函数，该函数的 this 关键字设置为指定值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> brand = car.<span class="hljs-property">getBrand</span>.<span class="hljs-title function_">bind</span>(car)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">brand</span>()) <span class="hljs-comment">// Honda</span><br></code></pre></td></tr></table></figure><p>在此示例中，当调用 brand() 方法时，this 关键字将绑定到 <code>car</code> 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> car = &#123;<br>  <span class="hljs-attr">brand</span>: <span class="hljs-string">&#x27;Honda&#x27;</span>,<br>  <span class="hljs-attr">getBrand</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span><br>  &#125;,<br>&#125;<br><span class="hljs-keyword">let</span> bike = &#123;<br>  <span class="hljs-attr">brand</span>: <span class="hljs-string">&#x27;Harley Davidson&#x27;</span>,<br>&#125;<br><span class="hljs-keyword">let</span> brand = car.<span class="hljs-property">getBrand</span>.<span class="hljs-title function_">bind</span>(bike)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">brand</span>()) <span class="hljs-comment">// Harley Davidson</span><br></code></pre></td></tr></table></figure><p>在此示例中，bind() 方法将 this 设置为 <code>bike</code> 对象，因此，可以在控制台上看到 <code>bike</code> 对象的品牌属性的值。</p><h3 id="Constructor-invocation"><a href="#Constructor-invocation" class="headerlink" title="Constructor invocation"></a>Constructor invocation</h3><p>当使用 new 关键字创建函数对象的实例时，将该函数用作构造函数。</p><p>以下示例声明一个 Car 函数，然后将其作为构造函数调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">brand</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span> = brand<br>&#125;<br><span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getBrand</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span><br>&#125;<br><span class="hljs-keyword">let</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&#x27;Honda&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(car.<span class="hljs-title function_">getBrand</span>())<br></code></pre></td></tr></table></figure><p>表达式 new Car(‘Honda’) 是 Car 函数的构造函数调用。</p><p>JavaScript 创建一个新对象并将 <code>this</code> 设置为新创建的对象。这种模式在只有一个潜在问题时效果很好。</p><p>现在，可以将 Car() 作为函数或构造函数调用。如果省略 new 关键字，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> bmw = <span class="hljs-title class_">Car</span>(<span class="hljs-string">&#x27;BMW&#x27;</span>) <span class="hljs-comment">// 返回 undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bmw.<span class="hljs-property">brand</span>)<br><span class="hljs-comment">// =&gt; TypeError: Cannot read property &#x27;brand&#x27; of undefined</span><br></code></pre></td></tr></table></figure><p>为了确保始终使用构造函数调用来调用 Car() 函数，请在 Car() 函数的开头添加一个检查，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">brand</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Car</span>)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Must use the new operator to call the function&#x27;</span>)<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span> = brand<br>&#125;<br></code></pre></td></tr></table></figure><p>ES6 引入了一个名为 new.target 的元属性，它允许检测函数是作为简单调用还是作为构造函数来调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">brand</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Must use the new operator to call the function&#x27;</span>)<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span> = brand<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Indirect-Invocation"><a href="#Indirect-Invocation" class="headerlink" title="Indirect Invocation"></a>Indirect Invocation</h3><p>在 JavaScript 中，函数是一等公民。换句话说，函数是对象，是 Function 类型的实例。</p><p>Function 类型有两个方法： call() 和 apply() 。这些方法允许在调用函数时设置 this 值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getBrand</span>(<span class="hljs-params">prefix</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(prefix + <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span>);<br>&#125;<br><span class="hljs-keyword">let</span> honda = &#123;<br>    <span class="hljs-attr">brand</span>: <span class="hljs-string">&#x27;Honda&#x27;</span><br>&#125;;<br><span class="hljs-keyword">let</span> audi = &#123;<br>    <span class="hljs-attr">brand</span>: <span class="hljs-string">&#x27;Audi&#x27;</span><br>&#125;;<br>getBrand.<span class="hljs-title function_">call</span>(honda, <span class="hljs-string">&quot;It&#x27;s a &quot;</span>);<br>getBrand.<span class="hljs-title function_">call</span>(audi, <span class="hljs-string">&quot;It&#x27;s an &quot;</span>);<br><span class="hljs-title class_">It</span><span class="hljs-string">&#x27;s a Honda</span><br><span class="hljs-string">It&#x27;</span>s an <span class="hljs-title class_">Audi</span><br></code></pre></td></tr></table></figure><p>apply() 方法与 call() 方法类似，只是它的第二个参数是参数数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">getBrand.<span class="hljs-title function_">apply</span>(honda, [<span class="hljs-string">&quot;It&#x27;s a &quot;</span>]) <span class="hljs-comment">// &quot;It&#x27;s a Honda&quot;</span><br>getBrand.<span class="hljs-title function_">apply</span>(audi, [<span class="hljs-string">&quot;It&#x27;s an &quot;</span>]) <span class="hljs-comment">// &quot;It&#x27;s a Audi&quot;</span><br></code></pre></td></tr></table></figure><h2 id="Arrow-function"><a href="#Arrow-function" class="headerlink" title="Arrow function"></a>Arrow function</h2><p>ES6 引入了一个新概念，称为箭头函数。在箭头函数中，JavaScript 按词法设置 this。</p><p>这意味着箭头函数不会创建自己的执行上下文，而是从定义箭头函数的外部函数继承 this 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">getThis</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">this</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getThis</span>() === <span class="hljs-variable language_">window</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>在此示例中， this 值设置为全局对象，即 Web 浏览器中的 window。</p><p>由于箭头函数不会创建自己的执行上下文，因此使用箭头函数定义方法会导致问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">speed</span> = <span class="hljs-number">120</span><br>&#125;<br><span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSpeed</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">speed</span><br>&#125;<br><span class="hljs-keyword">let</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(car.<span class="hljs-title function_">getSpeed</span>()) <span class="hljs-comment">// 👉 undefined</span><br></code></pre></td></tr></table></figure><p>在 getSpeed() 方法中， this 值引用全局对象，而不是 Car 对象，但全局对象没有名为 speed 的属性。因此，getSpeed() 方法中的 this.speed 返回 undefined。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript this</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Prototypal Inheritance</title>
    <link href="/2024/03/06/Prototypal-Inheritance/"/>
    <url>/2024/03/06/Prototypal-Inheritance/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction-to-JavaScript-prototypal-inheritance"><a href="#Introduction-to-JavaScript-prototypal-inheritance" class="headerlink" title="Introduction to JavaScript prototypal inheritance"></a>Introduction to JavaScript prototypal inheritance</h2><p>在 OOP 编程范式中，类是创建对象的蓝图。如果希望新类重用现有类的功能，可以创建一个扩展现有类的新类。这称为经典继承。</p><p>JavaScript 不使用经典继承。相反，它使用原型继承。</p><p>在原型继承中，一个对象通过原型链接从另一个对象“继承”属性。</p><h2 id="JavaScript-prototypal-inheritance-and-proto"><a href="#JavaScript-prototypal-inheritance-and-proto" class="headerlink" title="JavaScript prototypal inheritance and __proto__"></a>JavaScript prototypal inheritance and <code>__proto__</code></h2><p>下面定义了一个 person 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John Doe&#x27;</span>,<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hi, I&#x27;m &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>在此示例中，person 对象有一个属性和一个方法：</p><ul><li><p>name 是存储人名的属性。</p></li><li><p>greet 是一个以字符串形式返回问候语的方法。</p></li></ul><p>默认情况下，JavaScript 引擎提供内置的 Object() 函数和可由 Object.prototype 引用的匿名对象：</p><p><img src="https://www.javascripttutorial.net/wp-content/uploads/2022/01/JS-prototype.svg" alt="JavaScript Prototype"></p><p>这意味着 person 对象可以调用 Object.prototype 引用的匿名对象中定义的任何方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-title function_">toString</span>());<br>[object <span class="hljs-title class_">Object</span>]<br></code></pre></td></tr></table></figure><p>[object Object] 是对象的默认字符串表示形式。</p><p>当通过 person 调用 toString() 方法时，JavaScript 引擎无法在 person 对象上找到它。因此，它沿着原型链寻找 Object.prototype 对象中的方法。</p><p>要访问 person 对象的原型，可以使用 <code>__proto__ </code> 属性，如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">__proto__</span>)<br></code></pre></td></tr></table></figure><blockquote><p>注意，永远不应该在生产代码中使用 <strong>proto</strong> 属性。</p></blockquote><p>下面显示了 <code>person.__proto__</code> 和 Object.prototype 引用了同一个对象：</p><p>下面定义了具有 teach() 方法的 teacher 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> teacher = &#123;<br>  <span class="hljs-attr">teach</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">subject</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;I can teach &#x27;</span> + subject<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>与 person 对象一样，<code>teacher.__proto__</code> 引用了 Object.prototype，如下图所示：</p><p><img src="https://www.javascripttutorial.net/wp-content/uploads/2022/01/JavaScript-prototypal-inheritance-inherits-from-Object.svg" alt="img"></p><p>如果想让 teacher 对象访问 person 对象的所有方法和属性，可以将 teacher 对象的原型设置为 person 对象，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">teacher.<span class="hljs-property">__proto__</span> = person<br></code></pre></td></tr></table></figure><p><img src="https://www.javascripttutorial.net/wp-content/uploads/2022/01/JavaScript-prototypal-inheritance-example.svg" alt="img"></p><p>现在，teacher 对象可以通过原型链从 person 对象访问 name 属性和 greet() 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(teacher.<span class="hljs-property">name</span>) <span class="hljs-comment">// John Doe</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(teacher.<span class="hljs-title function_">greet</span>()) <span class="hljs-comment">// Hi, I&#x27;m John Doe</span><br></code></pre></td></tr></table></figure><p>当在 teacher 对象上调用 greet() 方法时，JavaScript 引擎首先在 teacher 对象中找到它。</p><p>由于 JavaScript 引擎无法在 teacher 对象中找到该方法，因此它沿着原型链在 person 对象中搜索该方法。因为 JavaScript 引擎可以在 person 对象中找到 greet() 方法，所以它会执行该方法。</p><p>在 JavaScript 中，我们说 teacher 对象继承了 person 对象的方法和属性。这种继承称为原型继承（<strong>prototypal inheritance</strong>）。</p><h2 id="A-standard-way-to-implement-prototypal-inheritance-in-ES5"><a href="#A-standard-way-to-implement-prototypal-inheritance-in-ES5" class="headerlink" title="A standard way to implement prototypal inheritance in ES5"></a>A standard way to implement prototypal inheritance in ES5</h2><p>ES5 通过使用 Object.create() 方法提供了一种处理原型继承的标准方法。</p><blockquote><p>注意，现在应该使用较新的 ES6 类和 extends 关键字来实现继承。简单多了。</p></blockquote><p>Object.create() 方法创建一个新对象并使用现有对象作为新对象的原型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto, [propertiesObject])<br></code></pre></td></tr></table></figure><p>Object.create() 方法接受两个参数：</p><ul><li>第一个参数 (proto) 是用作新对象的原型对象。</li><li>第二个参数 (propertiesObject)（如果提供）是一个可选对象，用于为新对象定义其他属性。</li></ul><p>假设有一个 person 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John Doe&#x27;</span>,<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hi, I&#x27;m &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>以下代码使用 person 对象作为原型对象创建一个空的 teacher 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> teacher = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(person)<br></code></pre></td></tr></table></figure><p>之后，可以为 teacher 对象定义属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">teacher.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jane Doe&#x27;</span><br>teacher.<span class="hljs-property">teach</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">subject</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;I can teach &#x27;</span> + subject<br>&#125;<br></code></pre></td></tr></table></figure><p>或者可以在一条语句中执行所有这些步骤，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> teacher = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(person, &#123;<br>  <span class="hljs-attr">name</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;John Doe&#x27;</span> &#125;,<br>  <span class="hljs-attr">teach</span>: &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">subject</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;I can teach &#x27;</span> + subject<br>    &#125;,<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>ES5 还引入了 Object.getPrototypeOf() 方法，该方法返回对象的原型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(teacher) === person) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript Prototype</tag>
      
      <tag>JavaScript Inheritance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript Constructor/Prototype Pattern</title>
    <link href="/2024/03/06/JavaScript-Constructor-Prototype-Pattern/"/>
    <url>/2024/03/06/JavaScript-Constructor-Prototype-Pattern/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction-to-the-JavaScript-Constructor-Prototype-pattern"><a href="#Introduction-to-the-JavaScript-Constructor-Prototype-pattern" class="headerlink" title="Introduction to the JavaScript Constructor &#x2F; Prototype pattern"></a>Introduction to the JavaScript Constructor &#x2F; Prototype pattern</h2><p>构造函数和原型模式的组合是 ES5 中定义自定义类型的最常见方法。在这个模式中：</p><ul><li>构造函数模式定义对象属性。</li><li>原型模式定义了对象方法。</li></ul><p>通过使用此模式，自定义类型的所有对象都共享原型中定义的方法。此外，每个对象都有自己的属性。</p><p>这种构造函数&#x2F;原型模式吸收了构造函数和原型模式的最佳部分。</p><h2 id="JavaScript-Constructor-Prototype-example"><a href="#JavaScript-Constructor-Prototype-example" class="headerlink" title="JavaScript Constructor &#x2F; Prototype example"></a>JavaScript Constructor &#x2F; Prototype example</h2><p>假设要定义一个名为 Person 的自定义类型，它具有：</p><ul><li>两个属性 firstName 和 lastName。</li><li>一个方法 getFullName()。</li></ul><p>首先，使用构造函数初始化属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">firstName, lastName</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(firstName, lastName)<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = lastName<br>&#125;<br></code></pre></td></tr></table></figure><p>在幕后，JavaScript 引擎定义了一个用圆圈表示的 Person 函数和一个用正方形表示的匿名对象。</p><p>Person 函数具有引用匿名对象的原型属性。匿名对象有一个引用 Person 函数的构造函数属性：</p><p><img src="https://www.javascripttutorial.net/wp-content/uploads/2022/01/JS-prototype-Person-prototype.svg" alt="JS prototype- Person prototype"></p><p>其次，在 Person 函数的原型对象中定义 getFullName() 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getFullName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript 在 Person.prototype 对象上定义了 getFullName() 方法，如下所示：</p><p><img src="https://www.javascripttutorial.net/wp-content/uploads/2022/01/JS-prototype-constructor-pattern.svg" alt="img"></p><p>第三，创建 Person 类型的多个实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;Doe&#x27;</span>)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Jane&#x27;</span>, <span class="hljs-string">&#x27;Doe&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">getFullName</span>())<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-title function_">getFullName</span>())<br><span class="hljs-comment">// 输出</span><br>;(<span class="hljs-string">&#x27;John Doe&#x27;</span>)<br>;(<span class="hljs-string">&#x27;Jane Doe&#x27;</span>)<br></code></pre></td></tr></table></figure><p>Javascript 创建两个对象 p1 和 p2。这些对象通过 [[Prototype]] 链接到 Person.prototype 对象：</p><p><img src="https://www.javascripttutorial.net/wp-content/uploads/2022/01/JavaScript-constructor-prototype-pattern-example.svg" alt="img"></p><p>每个对象都有自己的属性 firstName 和 lastName。但是，它们共享相同的 getFullName() 方法。</p><p>当对 p1 或 p2 对象调用 getFullName() 方法时，JavaScript 引擎会搜索这些对象的方法。因为 JavaScript 引擎在那里找不到该方法，所以它遵循原型链接并在 Person.prototype 对象中搜索该方法。</p><h2 id="Classes-in-ES6"><a href="#Classes-in-ES6" class="headerlink" title="Classes in ES6"></a>Classes in ES6</h2><p>ES6 引入了 class 关键字，使构造函数&#x2F;原型模式更易于使用。例如，以下使用 class 关键字定义相同的 Person 类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">firstName, lastName</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = lastName<br>  &#125;<br>  <span class="hljs-title function_">getFullName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;Doe&#x27;</span>)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Jane&#x27;</span>, <span class="hljs-string">&#x27;Doe&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">getFullName</span>())<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-title function_">getFullName</span>())<br></code></pre></td></tr></table></figure><p>在此语法中，类将属性初始化移至构造函数方法。它还将 getFullName() 方法定义在与构造函数相同的位置。</p><p>类语法看起来更干净、更简洁。然而，它是构造函数&#x2F;原型模式的语法糖，并具有一些增强功能。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript Prototype</tag>
      
      <tag>JavaScript Constructor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript Prototype</title>
    <link href="/2024/03/06/JavaScript-Prototype/"/>
    <url>/2024/03/06/JavaScript-Prototype/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction-to-JavaScript-prototype"><a href="#Introduction-to-JavaScript-prototype" class="headerlink" title="Introduction to JavaScript prototype"></a>Introduction to JavaScript prototype</h2><p>在 JavaScript 中，对象可以通过原型继承彼此的功能。每个对象都有自己的属性，称为 <code>prototype</code>。</p><p>因为原型本身也是另一个对象，所以原型有自己的原型。这创建了一个称为原型链（prototype chain）的东西。当原型的自身原型为空时，原型链结束。</p><p>假设有一个对象 person，其属性名为 name：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><p>当在控制台中检查 person 对象时，会发现 person 对象有一个名为 prototype 的属性，用 [[Prototype]] 表示：</p><img src="/2024/03/06/JavaScript-Prototype/JavaScript-Prototype.png" class=""><p>原型本身是一个具有自己属性的对象：</p><img src="/2024/03/06/JavaScript-Prototype/JavaScript-Prototype-object.png" class=""><p>当访问对象的属性时，如果该对象具有该属性，它将返回该属性值。</p><p>但是，如果访问对象中不存在的属性，JavaScript 引擎将在该对象的原型中搜索。</p><p>如果 JavaScript 引擎在对象的原型对象中找不到该属性，它将在原型的原型中搜索，直到找到该属性或到达原型链的末尾。</p><h2 id="JavaScript-prototype-illustration"><a href="#JavaScript-prototype-illustration" class="headerlink" title="JavaScript prototype illustration"></a>JavaScript prototype illustration</h2><p>JavaScript 具有内置的 Object() 函数。如果将 Object 函数传递给 typeof 运算符，则它会返回“function”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Object</span> <span class="hljs-comment">// &#x27;function&#x27;</span><br></code></pre></td></tr></table></figure><p>此外，JavaScript 提供了一个匿名对象，可以通过 Object() 函数的原型属性来引用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br></code></pre></td></tr></table></figure><img src="/2024/03/06/JavaScript-Prototype/JavaScript-Prototype-Object.prototype.png" class=""><p>Object.prototype 对象具有一些有用的属性和方法，例如 toString() 和 valueOf()。</p><p>Object.prototype 还有一个重要的属性：constructor，它引用 Object() 函数。</p><p>以下语句确认 Object.prototype.constructor 属性引用了 Object 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Object</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>首先，定义一个名为 Person 的构造函数，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br></code></pre></td></tr></table></figure><p>在此示例中，Person() 函数接受一个 name 参数并将其分配给 this 对象的 name 属性。</p><p>JavaScript 在幕后创建了一个新函数 Person() 和一个匿名对象：</p><p><img src="https://www.javascripttutorial.net/wp-content/uploads/2022/01/JS-prototype-Person-type.svg" alt="JS prototype- Person type"></p><p>与 Object() 函数一样，Person() 函数有一个名为 prototype 的属性，该属性引用匿名对象。匿名对象具有引用 Person() 函数的构造函数属性。</p><p>![img](D:\2024 年\blogs\Web Dev\JavaScript\ECMAScript\04-Objects\assets\JavaScript-Prototype-Person-function.png)</p><p><strong>此外，JavaScript 通过 [[Prototype]] 将 Person.prototype 对象链接到 Object.prototype 对象，这称为原型链接。</strong></p><p>原型链接在下图中用[[Prototype]]表示：</p><p><img src="https://www.javascripttutorial.net/wp-content/uploads/2022/01/JS-prototype-Person-prototype.svg" alt="JS prototype- Person prototype"></p><h2 id="Defining-methods-in-the-JavaScript-prototype-object"><a href="#Defining-methods-in-the-JavaScript-prototype-object" class="headerlink" title="Defining methods in the JavaScript prototype object"></a>Defining methods in the JavaScript prototype object</h2><p>下面在 Person.prototype 对象中定义了一个名为 greet()的新方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hi, I&#x27;m &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这种情况下，JavaScript 引擎将 greet()方法添加到 Person.prototype 对象中：</p><p><img src="https://www.javascripttutorial.net/wp-content/uploads/2022/01/JS-prototype-method.svg" alt="img"></p><p>以下创建了 Person 的一个新实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在内部，JavaScript 引擎创建一个名为 p1 的新对象，并通过原型链接将 p1 对象链接到 Person.prototype 对象：</p><p><img src="https://www.javascripttutorial.net/wp-content/uploads/2022/01/JS-prototype-Person-object.svg" alt="img"></p><p>p1、Person.prototype 和 Object.protoype 之间的链接称为原型链。</p><p>以下代码调用 p1 对象上的 greet()方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> greeting = p1.<span class="hljs-title function_">greet</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting)<br></code></pre></td></tr></table></figure><p>因为 p1 没有 greet()方法，所以 JavaScript 遵循原型链接并在 Person.prototype 对象上找到它。</p><p>由于 JavaScript 可以在 Person.prototype 对象上找到 greet() 方法，因此它执行 greet() 方法并返回结果：</p><p>下面调用 p1 对象的 toString() 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = p1.<span class="hljs-title function_">toString</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s)<br></code></pre></td></tr></table></figure><p>在这种情况下，JavaScript 引擎会沿着原型链在 Person.prototype 中查找 toString() 方法。</p><p>由于 Person.prototype 没有 toString() 方法，因此 JavaScript 引擎会向上查找原型链并在 Object.prototype 对象中搜索 toString() 方法。</p><p><img src="https://www.javascripttutorial.net/wp-content/uploads/2022/01/JS-prototype-calling-a-method.svg" alt="img"></p><p>如果调用 Person.prototype 和 Object.prototype 对象上不存在的方法，JavaScript 引擎将遵循原型链，如果找不到该方法，则会抛出错误。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">p1.<span class="hljs-title function_">fly</span>()<br></code></pre></td></tr></table></figure><p>由于 fly() 方法不存在于原型链中的任何对象上，因此 JavaScript 引擎会发出以下错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">TypeError</span>: p1.<span class="hljs-property">fly</span> is not a <span class="hljs-keyword">function</span><br></code></pre></td></tr></table></figure><p>下面创建了 name 属性为“Jane”的 Person 的另一个实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Jane&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://www.javascripttutorial.net/wp-content/uploads/2022/01/JS-prototype-two-person-objects.svg" alt="JS prototype-two person objects"></p><p>p2 对象具有与 p1 对象相同的属性和方法。</p><p>总之，当你在原型对象上定义一个方法时，这个方法被所有实例共享。</p><h2 id="Defining-methods-in-an-individual-object"><a href="#Defining-methods-in-an-individual-object" class="headerlink" title="Defining methods in an individual object"></a>Defining methods in an individual object</h2><p>下面定义了 p2 对象上的 draw() 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">p2.<span class="hljs-property">draw</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;I can draw.&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript 引擎将 draw() 方法添加到 p2 对象，而不是 Person.prototype 对象：</p><p><img src="https://www.javascripttutorial.net/wp-content/uploads/2022/01/JS-prototype-object-with-method.svg" alt="JS prototype - object with method"></p><p>这意味着只可以在 p2 对象上调用 draw() 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">p2.<span class="hljs-title function_">draw</span>()<br></code></pre></td></tr></table></figure><p>但是你不能在 p1 对象上调用 draw() 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">p1.<span class="hljs-title function_">draw</span>()<br><span class="hljs-title class_">TypeError</span>: p1.<span class="hljs-property">draw</span> is not a <span class="hljs-keyword">function</span><br></code></pre></td></tr></table></figure><p>当在对象中定义方法时，该方法仅对该对象可用。默认情况下它不能与其他对象共享。</p><h2 id="Getting-prototype-linkage"><a href="#Getting-prototype-linkage" class="headerlink" title="Getting prototype linkage"></a>Getting prototype linkage</h2><p><code>__proto__</code> 发音为 dunder proto。 <code>__proto__</code> 是 Object.prototype 对象的访问器属性。它公开了访问它的对象的内部原型链接（[[Prototype]]）。</p><p><code>__proto__ </code> 已在 ES6 中标准化，以确保与 Web 浏览器的兼容性。但是，将来可能会弃用它，转而使用 Object.getPrototypeOf()。因此，永远不应该在生产代码中使用 <code>__proto__</code>。</p><p><code>p1.__proto__</code> 公开引用 Person.prototype 对象的 [[Prototype]]。</p><p>同样，<code>p2.__proto__</code> 也引用与 <code>p1.__proto__</code> 相同的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">__proto__</span> === p2.<span class="hljs-property">__proto__</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如前所述，应该使用 Object.getPrototypeOf() 方法而不是 <code>__proto__</code>。 Object.getPrototypeOf() 方法返回指定对象的原型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(p1)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>获取原型链接的另一种流行方法是当 Object.getPrototypeOf() 方法无法通过构造函数属性使用时，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">p1.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure><p>p1.constructor 返回 Person，因此 p1.constructor.prototype 返回原型对象。</p><h2 id="Shadowing"><a href="#Shadowing" class="headerlink" title="Shadowing"></a>Shadowing</h2><p>观察以下方法调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">greet</span>())<br></code></pre></td></tr></table></figure><p>p1 对象没有定义 greet() 方法，因此 JavaScript 会沿着原型链查找它。在这种情况下，它可以在 Person.prototype 对象中找到该方法。</p><p>让我们向对象 p1 添加一个与 Person.prototype 对象中的方法同名的新方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">p1.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>并调用 greet() 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">greet</span>())<br></code></pre></td></tr></table></figure><p>因为 p1 对象有 greet() 方法，JavaScript 只是立即执行它，而无需在原型链中查找它。</p><p>这是 shadowing 的一个例子。 p1 对象的 greet() 方法隐藏了 p1 对象引用的原型对象的 greet() 方法。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript Prototype</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript Constructor Function</title>
    <link href="/2024/03/06/JavaScript-Constructor-Function/"/>
    <url>/2024/03/06/JavaScript-Constructor-Function/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction-to-JavaScript-constructor-functions"><a href="#Introduction-to-JavaScript-constructor-functions" class="headerlink" title="Introduction to JavaScript constructor functions"></a>Introduction to JavaScript constructor functions</h2><p>可以使用构造函数来定义自定义类型，并使用 new 运算符从该类型创建多个对象。</p><p>从技术上讲，任何函数（除了箭头函数，它没有自己的 <code>this</code>）都可以用作构造器。即可以通过 <code>new</code> 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 <code>new</code> 来运行。</p><p>构造函数是具有以下约定的常规函数：</p><ul><li>构造函数的名称以大写字母开头，如 Person、Document 等。</li><li>构造函数只能使用 new 运算符调用。</li></ul><p>注意，ES6 引入了 class 关键字，允许定义自定义类型。<strong>类只是构造函数的语法糖，具有一些增强功能。</strong></p><p>以下示例定义了一个名为 Person 的构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">firstName, lastName</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = lastName<br>&#125;<br></code></pre></td></tr></table></figure><p>要创建 Person 的新实例，使用 new 运算符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;Doe&#x27;</span>)<br></code></pre></td></tr></table></figure><p>基本上，new 运算符执行以下操作：</p><ul><li>创建一个新的空对象 {} 并将其分配给 this。</li><li>函数体执行。通常它会修改 <code>this</code>，为其添加新的属性，将参数“John”和“Doe”分配给对象的 firstName 和 lastName 属性。</li><li>返回 this 值。</li></ul><p>它在功能上等同于以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">firstName, lastName</span>) &#123;<br>  <span class="hljs-comment">// this = &#123;&#125;;</span><br>  <span class="hljs-comment">// add properties to this</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = lastName<br>  <span class="hljs-comment">// return this;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>顺便说一下，如果没有参数，可以省略 <code>new</code> 后的括号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>() <span class="hljs-comment">// &lt;-- 没有参数</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>()<br></code></pre></td></tr></table></figure><p>这里省略括号不被认为是一种“好风格”，但是规范允许使用该语法。</p><h2 id="Adding-methods-to-JavaScript-constructor-functions"><a href="#Adding-methods-to-JavaScript-constructor-functions" class="headerlink" title="Adding methods to JavaScript constructor functions"></a>Adding methods to JavaScript constructor functions</h2><p>对象可能具有操作其数据的方法。要向通过构造函数创建的对象添加方法，可以使用 this 关键字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">firstName, lastName</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = lastName<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">getFullName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，可以创建一个新的 Person 对象并调用 getFullName() 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;Doe&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-title function_">getFullName</span>()) <span class="hljs-comment">// John Doe</span><br></code></pre></td></tr></table></figure><p>构造函数的问题在于，当创建 Person 的多个实例时， this.getFullName() 会在每个实例中重复（不共享），这样内存效率不高。</p><p>要解决此问题，可以使用原型，以便自定义类型的所有实例都可以共享相同的方法。</p><h2 id="Returning-from-constructor-functions"><a href="#Returning-from-constructor-functions" class="headerlink" title="Returning from constructor functions"></a>Returning from constructor functions</h2><p>通常，构造函数隐式返回设置为新创建对象的 this 。但如果它有 return 语句，则规则如下：</p><ul><li>如果使用对象调用 return，构造函数将返回该对象而不是 this。</li><li>如果使用对象以外的值调用 return，则该值将被忽略。</li></ul><p>换句话说，带有对象的 <code>return</code> 返回该对象，在所有其他情况下返回 <code>this</code>。</p><h2 id="Calling-a-constructor-function-without-the-new-keyword"><a href="#Calling-a-constructor-function-without-the-new-keyword" class="headerlink" title="Calling a constructor function without the new keyword"></a>Calling a constructor function without the <code>new</code> keyword</h2><p>从技术上讲，可以像常规函数一样调用构造函数，而无需使用 new 关键字，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;Doe&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在这种情况下，Person 只是像常规函数一样执行。因此，Person 函数中的 this 并不绑定到 person 变量，而是绑定到全局对象。</p><p>如果尝试访问 firstName 或 lastName 属性，将收到错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">firstName</span>);<br><span class="hljs-title class_">TypeError</span>: <span class="hljs-title class_">Cannot</span> read property <span class="hljs-string">&#x27;firstName&#x27;</span> <span class="hljs-keyword">of</span> <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><p>同样，无法访问 getFullName() 方法，因为它绑定到全局对象。</p><p>为了防止在没有 new 关键字的情况下调用构造函数，ES6 引入了 new.target 属性。</p><p>如果使用 new 关键字调用构造函数，则 new.target 返回该函数的引用。否则，它返回 undefined。</p><p>下面向 Person 函数添加一条语句，以将 new.target 显示到控制台：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">firstName, lastName</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>)<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = lastName<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">getFullName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下返回 undefined，因为 Person 构造函数的调用方式与常规函数类似：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;Doe&#x27;</span>) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>但是，以下代码返回对 Person 函数的引用，因为它被称为 new 关键字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;Doe&#x27;</span>) <span class="hljs-comment">// [Function: Person]</span><br></code></pre></td></tr></table></figure><p>通过使用 new.target，可以强制构造函数的调用者使用 new 关键字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">firstName, lastName</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Cannot be called without the new keyword&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = lastName<br>&#125;<br></code></pre></td></tr></table></figure><p>或者，如果构造函数的用户不使用 new 关键字，则可以通过创建新的 Person 对象来使语法更加灵活：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">firstName, lastName</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(firstName, lastName)<br>  &#125;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = lastName<br>&#125;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;Doe&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">firstName</span>)<br></code></pre></td></tr></table></figure><p>这种模式经常用于 JavaScript 库和框架中，以使语法更加灵活。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript Function</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript Arrow Functions</title>
    <link href="/2024/03/06/JavaScript-Arrow-Functions/"/>
    <url>/2024/03/06/JavaScript-Arrow-Functions/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction-to-JavaScript-arrow-functions"><a href="#Introduction-to-JavaScript-arrow-functions" class="headerlink" title="Introduction to JavaScript arrow functions"></a>Introduction to JavaScript arrow functions</h2><p>ES6 箭头函数提供了一种替代方法来编写比函数表达式更短的语法。</p><p>以下示例定义一个返回两个数字之和的函数表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> add = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)) <span class="hljs-comment">// 30</span><br></code></pre></td></tr></table></figure><p>以下示例等效于上面的 add() 函数表达式，但使用箭头函数代替：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">x, y</span>) =&gt; x + y<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)) <span class="hljs-comment">// 30;</span><br></code></pre></td></tr></table></figure><p>在此示例中，箭头函数有一个表达式 x + y，因此它返回该表达式的结果。</p><p>但是，如果使用块语法 {}，则需要指定 return 关键字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">x, y</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> x + y<br>&#125;<br></code></pre></td></tr></table></figure><p>typeof 运算符返回指示箭头函数类型为 function。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> add) <span class="hljs-comment">// function</span><br></code></pre></td></tr></table></figure><p>箭头函数也是 Function 类型的实例，如下例所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(add <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="JavaScript-arrow-functions-with-multiple-parameters"><a href="#JavaScript-arrow-functions-with-multiple-parameters" class="headerlink" title="JavaScript arrow functions with multiple parameters"></a>JavaScript arrow functions with multiple parameters</h3><p>如果箭头函数有两个或多个参数，则使用以下语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">(p1, p2, ..., pn) =&gt; expression;<br></code></pre></td></tr></table></figure><p>例如，要按降序对数字数组进行排序，可以使用数组对象的 sort() 方法，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>]<br>numbers.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> b - a<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers) <span class="hljs-comment">// [6,4,2]</span><br></code></pre></td></tr></table></figure><p>使用箭头函数语法，代码更加简洁：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>]<br>numbers.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers) <span class="hljs-comment">// [6,4,2]</span><br></code></pre></td></tr></table></figure><h3 id="JavaScript-arrow-functions-with-a-single-parameter"><a href="#JavaScript-arrow-functions-with-a-single-parameter" class="headerlink" title="JavaScript arrow functions with a single parameter"></a>JavaScript arrow functions with a single parameter</h3><p>如果箭头函数采用单个参数，则使用以下语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">;<span class="hljs-function">(<span class="hljs-params">p1</span>) =&gt;</span> &#123;<br>  statements<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，可以省略括号，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">;<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> &#123;<br>  statements<br>&#125;<br></code></pre></td></tr></table></figure><p>以下示例使用箭头函数作为 map() 方法的参数，该方法将字符串数组转换为字符串长度数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> names = [<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;Mac&#x27;</span>, <span class="hljs-string">&#x27;Peter&#x27;</span>]<br><span class="hljs-keyword">let</span> lengths = names.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> name.<span class="hljs-property">length</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lengths) <span class="hljs-comment">// [ 4, 3, 5 ]</span><br></code></pre></td></tr></table></figure><h3 id="JavaScript-arrow-functions-with-no-parameter"><a href="#JavaScript-arrow-functions-with-no-parameter" class="headerlink" title="JavaScript arrow functions with no parameter"></a>JavaScript arrow functions with no parameter</h3><p>如果箭头函数没有参数，则必须需要使用括号，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">;<span class="hljs-function">() =&gt;</span> &#123;<br>  statements<br>&#125;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">logDoc</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">document</span>)<br><span class="hljs-title function_">logDoc</span>()<br></code></pre></td></tr></table></figure><h2 id="Statements-expressions-in-the-arrow-function-body"><a href="#Statements-expressions-in-the-arrow-function-body" class="headerlink" title="Statements &amp; expressions in the arrow function body"></a>Statements &amp; expressions in the arrow function body</h2><p>在 JavaScript 中，表达式的计算结果为如下例所示的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">10</span> + <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>语句执行特定任务，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (x === y) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x equals y&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在箭头函数体中使用一个表达式，则不需要使用 {}。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">square</span> = (<span class="hljs-params">x</span>) =&gt; x * x<br></code></pre></td></tr></table></figure><p>但是，如果使用一条语句，则必须将其括在一对大括号内，如下例所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">except</span> = (<span class="hljs-params">msg</span>) =&gt; &#123;<br>  <span class="hljs-keyword">throw</span> msg<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JavaScript-arrow-functions-and-object-literal"><a href="#JavaScript-arrow-functions-and-object-literal" class="headerlink" title="JavaScript arrow functions and object literal"></a>JavaScript arrow functions and object literal</h2><p>考虑以下示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> setColor = <span class="hljs-keyword">function</span> (<span class="hljs-params">color</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: color &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> backgroundColor = <span class="hljs-title function_">setColor</span>(<span class="hljs-string">&#x27;Red&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(backgroundColor.<span class="hljs-property">value</span>) <span class="hljs-comment">// &quot;Red&quot;</span><br></code></pre></td></tr></table></figure><p>setColor() 函数表达式返回一个对象，该对象的 value 属性设置为 color 参数。</p><p>如果使用以下语法从箭头函数返回对象字面量，将不会起作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">;<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> &#123;<br>  <span class="hljs-attr">object</span>: literal<br>&#125;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">setColor</span> = (<span class="hljs-params">color</span>) =&gt; &#123;<br>  <span class="hljs-attr">value</span>: color<br>&#125;<br></code></pre></td></tr></table></figure><p>由于块和对象字面量都使用大括号，因此 JavaScript 引擎无法区分块和对象。</p><p>要解决此问题，需要将对象字面量括在括号中，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">setColor</span> = (<span class="hljs-params">color</span>) =&gt; (&#123; <span class="hljs-attr">value</span>: color &#125;)<br></code></pre></td></tr></table></figure><h2 id="Arrow-function-vs-regular-function"><a href="#Arrow-function-vs-regular-function" class="headerlink" title="Arrow function vs. regular function"></a>Arrow function vs. regular function</h2><p>箭头函数和常规函数之间有两个主要区别。</p><ul><li>首先，在箭头函数中，this、arguments、super、new.target 是词法的。这意味着箭头函数使用封闭词法范围（enclosing lexical scope）中的这些变量。</li><li>其次，箭头函数不能用作函数构造器。如果使用 new 关键字从箭头函数创建新对象，将收到错误。</li></ul><h3 id="JavaScript-arrow-functions-and-this-value"><a href="#JavaScript-arrow-functions-and-this-value" class="headerlink" title="JavaScript arrow functions and this value"></a>JavaScript arrow functions and <code>this</code> value</h3><p>在 JavaScript 中，一个新函数定义了自己的 this 值。然而，箭头函数的情况并非如此。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">speed</span> = <span class="hljs-number">0</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">speedUp</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">speed</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">speed</span> = speed<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">speed</span>) <span class="hljs-comment">// undefined</span><br>    &#125;, <span class="hljs-number">1000</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>()<br>car.<span class="hljs-title function_">speedUp</span>(<span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure><p>在 setTimeout()函数的匿名函数中，this.speed 是 undefined。原因是匿名函数的 this 遮盖了 speedUp() 方法的 this，因为匿名函数中的 this 指向全局对象。</p><p>要解决此问题，可以将 this 值分配给一个不在匿名函数内部隐藏的变量，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">speed</span> = <span class="hljs-number">0</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">speedUp</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">speed</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">speed</span> = speed<br>    <span class="hljs-keyword">let</span> self = <span class="hljs-variable language_">this</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(self.<span class="hljs-property">speed</span>)<br>    &#125;, <span class="hljs-number">1000</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>()<br>car.<span class="hljs-title function_">speedUp</span>(<span class="hljs-number">50</span>) <span class="hljs-comment">// 50;</span><br></code></pre></td></tr></table></figure><p>与匿名函数不同，箭头函数捕获封闭上下文（enclosing context）的 this 值，而不是创建自己的 this 上下文。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">speed</span> = <span class="hljs-number">0</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">speedUp</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">speed</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">speed</span> = speed<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">speed</span>), <span class="hljs-number">1000</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>()<br>car.<span class="hljs-title function_">speedUp</span>(<span class="hljs-number">50</span>) <span class="hljs-comment">// 50;</span><br></code></pre></td></tr></table></figure><h3 id="JavaScript-arrow-functions-and-the-arguments-object"><a href="#JavaScript-arrow-functions-and-the-arguments-object" class="headerlink" title="JavaScript arrow functions and the arguments object"></a>JavaScript arrow functions and the arguments object</h3><p>箭头函数没有 arguments 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x + <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-keyword">let</span> display = <span class="hljs-title function_">show</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">display</span>(<span class="hljs-number">5</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result) <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><p>showMe() 函数内的箭头函数引用 arguments 对象。然而，这个 arguments 对象属于 show()函数，而不是箭头函数。</p><p>此外，箭头函数没有 new.target 关键字。</p><h3 id="JavaScript-arrow-functions-and-the-prototype-property"><a href="#JavaScript-arrow-functions-and-the-prototype-property" class="headerlink" title="JavaScript arrow functions and the prototype property"></a>JavaScript arrow functions and the prototype property</h3><p>当使用 function 关键字定义函数时，该函数有一个称为原型的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dump</span>(<span class="hljs-params">message</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dump.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;prototype&#x27;</span>)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>然而，箭头函数没有原型属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">dump</span> = (<span class="hljs-params">message</span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dump.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;prototype&#x27;</span>)) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>使用箭头函数进行回调和闭包是一种很好的做法，因为箭头函数的语法更清晰。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES 6</tag>
      
      <tag>JavaScript Function</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript for...of Loop</title>
    <link href="/2024/03/06/JavaScript-for-of-Loop/"/>
    <url>/2024/03/06/JavaScript-for-of-Loop/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction-to-the-JavaScript-for…of-loop"><a href="#Introduction-to-the-JavaScript-for…of-loop" class="headerlink" title="Introduction to the JavaScript for…of loop"></a>Introduction to the JavaScript for…of loop</h2><p>ES6 引入了一个新的语句 for…of 来迭代可迭代对象：</p><ul><li>Built-in Array, String, Map, Set, …</li><li>Array-like objects such as arguments or NodeList</li><li>User-defined objects that implement the iterator protocol.</li></ul><p>for…of 的语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (variable <span class="hljs-keyword">of</span> iterable) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JavaScript-for-of-loop-examples"><a href="#JavaScript-for-of-loop-examples" class="headerlink" title="JavaScript for of loop examples"></a>JavaScript for of loop examples</h2><h3 id="Iterating-over-arrays"><a href="#Iterating-over-arrays" class="headerlink" title="Iterating over arrays"></a>Iterating over arrays</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> scores = [<span class="hljs-number">80</span>, <span class="hljs-number">90</span>, <span class="hljs-number">70</span>]<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> score <span class="hljs-keyword">of</span> scores) &#123;<br>  score = score + <span class="hljs-number">5</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(score)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不更改循环内的变量，则应使用 const 关键字而不是 let 关键字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> scores = [<span class="hljs-number">80</span>, <span class="hljs-number">90</span>, <span class="hljs-number">70</span>]<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> score <span class="hljs-keyword">of</span> scores) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(score)<br>&#125;<br></code></pre></td></tr></table></figure><p>要访问循环内数组元素的索引，可以将 for…of 语句与数组的 entries() 方法结合使用。</p><p>array.entries() 方法在每次迭代中返回一对 [index, element]。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&#x27;Red&#x27;</span>, <span class="hljs-string">&#x27;Green&#x27;</span>, <span class="hljs-string">&#x27;Blue&#x27;</span>]<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [index, color] <span class="hljs-keyword">of</span> colors.<span class="hljs-title function_">entries</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;color&#125;</span> is at index <span class="hljs-subst">$&#123;index&#125;</span>`</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在此示例中，使用了数组解构将 entries() 方法的结果分配给每次迭代中的 index 和 color 变量。</p><h3 id="In-place-object-destructuring-with-for…of"><a href="#In-place-object-destructuring-with-for…of" class="headerlink" title="In-place object destructuring with for…of"></a>In-place object destructuring with for…of</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ratings = [<br>  &#123; <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-attr">score</span>: <span class="hljs-number">3</span> &#125;,<br>  &#123; <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;Jane&#x27;</span>, <span class="hljs-attr">score</span>: <span class="hljs-number">4</span> &#125;,<br>  &#123; <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;David&#x27;</span>, <span class="hljs-attr">score</span>: <span class="hljs-number">5</span> &#125;,<br>  &#123; <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;Peter&#x27;</span>, <span class="hljs-attr">score</span>: <span class="hljs-number">2</span> &#125;,<br>]<br><br><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> &#123; score &#125; <span class="hljs-keyword">of</span> ratings) &#123;<br>  sum += score<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Total scores: <span class="hljs-subst">$&#123;sum&#125;</span>`</span>) <span class="hljs-comment">// 14</span><br></code></pre></td></tr></table></figure><ul><li>The <code>ratings</code> is an array of objects. Each object has two properties user and score.</li><li>The <code>for...of</code> iterate over the <code>ratings</code> array and calculate the total scores of all objects.</li><li>The expression const {score} of ratings uses object destructing to assign the score property of the current iterated element to the score variable.</li></ul><h3 id="Iterating-over-strings"><a href="#Iterating-over-strings" class="headerlink" title="Iterating over strings"></a>Iterating over strings</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c <span class="hljs-keyword">of</span> str) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Iterating-over-Map-objects"><a href="#Iterating-over-Map-objects" class="headerlink" title="Iterating over Map objects"></a>Iterating over Map objects</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br><br>colors.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;#ff0000&#x27;</span>)<br>colors.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;#00ff00&#x27;</span>)<br>colors.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;#0000ff&#x27;</span>)<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> color <span class="hljs-keyword">of</span> colors) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(color)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">;[<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;#ff0000&#x27;</span>][(<span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;#00ff00&#x27;</span>)][(<span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;#0000ff&#x27;</span>)]<br></code></pre></td></tr></table></figure><h3 id="Iterating-over-set-objects"><a href="#Iterating-over-set-objects" class="headerlink" title="Iterating over set objects"></a>Iterating over set objects</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="for-of-vs-for-in"><a href="#for-of-vs-for-in" class="headerlink" title="for...of vs. for...in"></a><code>for...of</code> vs. <code>for...in</code></h2><p>JavaScript 中的 <code>for...in</code> 循环会迭代对象的所有可枚举属性，包括对象自身的属性以及其原型链上的属性。这意味着 <code>for...in</code> 循环会遍历对象自身的属性，同时也会遍历其原型链上可枚举的属性。如果想要避免遍历原型链上的属性，可以使用 <code>Object.hasOwnProperty()</code> 方法来过滤出对象自身的属性。</p><p>for…in 迭代对象的所有可枚举属性。它不会迭代 Array、Map 或 Set 等集合。</p><p>与 for…in 循环不同，for…of 迭代一个集合，而不是一个对象。事实上，for…of 会迭代任何具有 [Symbol.iterator] 属性的集合的元素。</p><p>数组是一种特殊的对象，它的属性名是数字索引，而属性值则是数组中的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> scores = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br>scores.<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;Hi&#x27;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;for...in:&#x27;</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> score <span class="hljs-keyword">in</span> scores) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(score)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;for...of:&#x27;</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> score <span class="hljs-keyword">of</span> scores) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(score)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>...<span class="hljs-attr">in</span>:<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br>message<br><span class="hljs-keyword">for</span>...<span class="hljs-attr">of</span>:<br><span class="hljs-number">10</span><br><span class="hljs-number">20</span><br><span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p>在此示例中，for…in 语句迭代 scores 数组的属性，而 for…of 则迭代数组的元素。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES 6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript Spread Operator</title>
    <link href="/2024/03/06/JavaScript-Spread-Operator/"/>
    <url>/2024/03/06/JavaScript-Spread-Operator/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction-to-the-JavaScript-spread-operator"><a href="#Introduction-to-the-JavaScript-spread-operator" class="headerlink" title="Introduction to the JavaScript spread operator"></a>Introduction to the JavaScript spread operator</h2><p>ES6 提供了一个新的运算符，称为展开运算符，它由三个点 (…) 组成。展开运算符扩展可迭代对象（例如数组、映射或集合）的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> odd = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">const</span> combined = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, ...odd]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(combined) <span class="hljs-comment">// [ 2, 4, 6, 1, 3, 5 ]</span><br></code></pre></td></tr></table></figure><p>位于奇数数组前面的三个点 (…) 是展开运算符。展开运算符 (…) 解包（unpack）奇数数组的元素。</p><blockquote><p>ES6 还具有三个点 (…)，这是一个 rest parameter，它将函数的所有剩余参数收集到一个数组中。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a, b, ...args</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)<br>&#125;<br><br><span class="hljs-title function_">f</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// [ 3, 4, 5 ]</span><br></code></pre></td></tr></table></figure><p>因此，三个点 (…) 同时表示 spread operator 和 rest parameter。</p><p>主要区别：</p><ul><li>spread operator 解包 <strong>可迭代对象（iterable object）</strong>的元素。</li><li>rest parameter 将元素打包到数组中。</li></ul><p>rest parameter 必须是函数的最后一个参数。然而，扩展运算符可以在任何地方：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> odd = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">const</span> combined = [...odd, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(combined) <span class="hljs-comment">// [ 1, 3, 5, 2, 4, 6 ]</span><br><br><span class="hljs-keyword">const</span> odd = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">const</span> combined = [<span class="hljs-number">2</span>, ...odd, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(combined) <span class="hljs-comment">// [2, 1, 3, 5, 4, 6]</span><br></code></pre></td></tr></table></figure><blockquote><p>ES2018 将 spead operator 扩展到对象，这称为 object spread。</p></blockquote><h2 id="JavaScript-spread-operator-and-apply-method"><a href="#JavaScript-spread-operator-and-apply-method" class="headerlink" title="JavaScript spread operator and apply() method"></a>JavaScript spread operator and apply() method</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compare</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a - b<br>&#125;<br></code></pre></td></tr></table></figure><p>在 ES5 中，要将两个数字的数组传递给 compare() 函数，通常使用 apply() 方法，因为 apply() 方法的参数传递是以数组的形式并自动解包的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result = compare.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result) <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><p>但是，通过使用扩展运算符，可以将两个数字的数组传递给 compare()函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">compare</span>(...[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result) <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><p>展开运算符展开数组的元素。</p><h2 id="A-better-way-to-use-the-Array’s-push-method-example"><a href="#A-better-way-to-use-the-Array’s-push-method-example" class="headerlink" title="A better way to use the Array’s push() method example"></a>A better way to use the Array’s push() method example</h2><p>数组对象的 push() 方法向数组添加一个或多个元素。如果要将数组传递给 push() 方法，则需要使用 apply() 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> rivers = [<span class="hljs-string">&#x27;Nile&#x27;</span>, <span class="hljs-string">&#x27;Ganges&#x27;</span>, <span class="hljs-string">&#x27;Yangte&#x27;</span>]<br><span class="hljs-keyword">let</span> moreRivers = [<span class="hljs-string">&#x27;Danube&#x27;</span>, <span class="hljs-string">&#x27;Amazon&#x27;</span>]<br><br>;[].<span class="hljs-property">push</span>.<span class="hljs-title function_">apply</span>(rivers, moreRivers)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rivers) <span class="hljs-comment">// [ &#x27;Nile&#x27;, &#x27;Ganges&#x27;, &#x27;Yangte&#x27;, &#x27;Danube&#x27;, &#x27;Amazon&#x27; ]</span><br></code></pre></td></tr></table></figure><p>使用扩展运算符来提高代码的可读性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">rivers.<span class="hljs-title function_">push</span>(...moreRivers)<br></code></pre></td></tr></table></figure><h2 id="JavaScript-spread-operator-and-array-manipulation"><a href="#JavaScript-spread-operator-and-array-manipulation" class="headerlink" title="JavaScript spread operator and array manipulation"></a>JavaScript spread operator and array manipulation</h2><h3 id="Constructing-array-literal"><a href="#Constructing-array-literal" class="headerlink" title="Constructing array literal"></a>Constructing array literal</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> initialChars = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>]<br><span class="hljs-keyword">let</span> chars = [...initialChars, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chars) <span class="hljs-comment">// [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="Concatenating-arrays"><a href="#Concatenating-arrays" class="headerlink" title="Concatenating arrays"></a>Concatenating arrays</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><span class="hljs-keyword">let</span> moreNumbers = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">let</span> allNumbers = [...numbers, ...moreNumbers]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(allNumbers) <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h3 id="Copying-an-array"><a href="#Copying-an-array" class="headerlink" title="Copying an array"></a>Copying an array</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> scores = [<span class="hljs-number">80</span>, <span class="hljs-number">70</span>, <span class="hljs-number">90</span>]<br><span class="hljs-keyword">let</span> copiedScores = [...scores]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(copiedScores) <span class="hljs-comment">// [80, 70, 90]</span><br></code></pre></td></tr></table></figure><h3 id="JavaScript-spread-operator-and-strings"><a href="#JavaScript-spread-operator-and-strings" class="headerlink" title="JavaScript spread operator and strings"></a>JavaScript spread operator and strings</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> chars = [<span class="hljs-string">&#x27;A&#x27;</span>, ...<span class="hljs-string">&#x27;BC&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chars) <span class="hljs-comment">// [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES 6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript Default Parameters</title>
    <link href="/2024/03/06/JavaScript-Default-Parameters/"/>
    <url>/2024/03/06/JavaScript-Default-Parameters/</url>
    
    <content type="html"><![CDATA[<h2 id="Setting-JavaScript-default-parameters-for-a-function"><a href="#Setting-JavaScript-default-parameters-for-a-function" class="headerlink" title="Setting JavaScript default parameters for a function"></a>Setting JavaScript default parameters for a function</h2><p>在 JavaScript 中，参数的默认值是 <code>undefined</code>。这意味着，如果不将参数传递给函数，则其参数的默认值将是 undefined。</p><p>假设要为 message 参数指定默认值 ‘Hi’。</p><p>实现此目的的典型方法是使用三元运算符测试参数值并分配默认值（如果未定义）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">message</span>) &#123;<br>  message = <span class="hljs-keyword">typeof</span> message !== <span class="hljs-string">&#x27;undefined&#x27;</span> ? message : <span class="hljs-string">&#x27;Hi&#x27;</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message)<br>&#125;<br><span class="hljs-title function_">say</span>() <span class="hljs-comment">// &#x27;Hi&#x27;</span><br></code></pre></td></tr></table></figure><p>ES6 提供了一种更简单的方法来设置函数参数的默认值，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">param1=default1, param2=default2,..</span>) &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的语法中，可以使用赋值运算符 (&#x3D;) 和参数名称后面的默认值来设置该参数的默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">message = <span class="hljs-string">&#x27;Hi&#x27;</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message)<br>&#125;<br><br><span class="hljs-title function_">say</span>() <span class="hljs-comment">// &#x27;Hi&#x27;</span><br><span class="hljs-title function_">say</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// &#x27;Hi&#x27;</span><br><span class="hljs-title function_">say</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// &#x27;Hello&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="Using-functions"><a href="#Using-functions" class="headerlink" title="Using functions"></a>Using functions</h3><p>可以使用函数的返回值作为参数的默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">taxRate</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-number">0.1</span><br><span class="hljs-keyword">let</span> getPrice = <span class="hljs-keyword">function</span> (<span class="hljs-params">price, tax = price * taxRate()</span>) &#123;<br>  <span class="hljs-keyword">return</span> price + tax<br>&#125;<br><br><span class="hljs-keyword">let</span> fullPrice = <span class="hljs-title function_">getPrice</span>(<span class="hljs-number">100</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fullPrice) <span class="hljs-comment">// 110</span><br></code></pre></td></tr></table></figure><h3 id="The-arguments-object"><a href="#The-arguments-object" class="headerlink" title="The arguments object"></a>The arguments object</h3><p>函数内 arguments 对象的值是传递给函数的实际参数的数量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y = <span class="hljs-number">1</span>, z = <span class="hljs-number">2</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>)<br>  <span class="hljs-keyword">return</span> x + y + z<br>&#125;<br><br><span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) <span class="hljs-comment">// 2</span><br><span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES 6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript Rest Parameters</title>
    <link href="/2024/03/06/JavaScript-Rest-Parameters/"/>
    <url>/2024/03/06/JavaScript-Rest-Parameters/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction-to-JavaScript-rest-parameters"><a href="#Introduction-to-JavaScript-rest-parameters" class="headerlink" title="Introduction to JavaScript rest parameters"></a>Introduction to JavaScript rest parameters</h2><p>ES6 提供了一种新的参数，称为 rest parameter，其前缀为三个点 (…)。rest parameter 允许将不定数量的参数表示为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a, b, ...args</span>) &#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后一个参数 (args) 以三个点 (…) 为前缀。它称为 rest parameter。</p><p>传递给函数的所有实参都将映射到参数列表。在上面的语法中，第一个参数映射到 a，第二个参数映射到 b，第三个、第四个等将作为数组存储在 rest parameter args 中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>)<br></code></pre></td></tr></table></figure><p>args 数组存储以下值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">;[<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]<br></code></pre></td></tr></table></figure><p>如果仅传递前两个参数，则 rest parameter 将为空数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>注意，rest parameter 必须出现在参数列表的末尾。以下代码将导致错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a,...rest, b</span>) &#123;<br> <span class="hljs-comment">// error</span><br>&#125;<br><span class="hljs-title class_">SyntaxError</span>: <span class="hljs-title class_">Rest</span> parameter must be last formal parameter<br></code></pre></td></tr></table></figure><h2 id="More-JavaScript-rest-parameters-examples"><a href="#More-JavaScript-rest-parameters-examples" class="headerlink" title="More JavaScript rest parameters examples"></a>More JavaScript rest parameters examples</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> a <span class="hljs-keyword">of</span> args) &#123;<br>    total += a<br>  &#125;<br>  <span class="hljs-keyword">return</span> total<br>&#125;<br><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><p>在此示例中，args 在数组中。因此，可以使用 for..of 循环来迭代其元素并对它们求和。</p><p>假设 sum() 函数的调用者可以传递各种数据类型的参数，例如数字、字符串和布尔值，并且只想计算数字的总和：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-keyword">return</span> args<br>    .<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> e === <span class="hljs-string">&#x27;number&#x27;</span><br>    &#125;)<br>    .<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">prev, curr</span>) &#123;<br>      <span class="hljs-keyword">return</span> prev + curr<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>以下脚本使用新的 sum() 函数仅对数字参数求和：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">sum</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;Hi&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">20</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result) <span class="hljs-comment">// 30</span><br></code></pre></td></tr></table></figure><p>如果没有 rest parameter，必须使用函数的 arguments 对象。</p><p>但是，arguments 对象本身并不是 Array 类型的实例。因此，不能直接使用 filter() 方法。在 ES5 中，必须使用 Array.prototype.filter.call()，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">filter</span><br>    .<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> e === <span class="hljs-string">&#x27;number&#x27;</span><br>    &#125;)<br>    .<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">prev, curr</span>) &#123;<br>      <span class="hljs-keyword">return</span> prev + curr<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>rest 参数使代码更加优雅。假设需要根据特定类型（例如数字、字符串、布尔值和 null）过滤参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">filterBy</span>(<span class="hljs-params">type, ...args</span>) &#123;<br>  <span class="hljs-keyword">return</span> args.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> e === type<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JavaScript-rest-parameters-and-arrow-function"><a href="#JavaScript-rest-parameters-and-arrow-function" class="headerlink" title="JavaScript rest parameters and arrow function"></a>JavaScript rest parameters and arrow function</h2><p>箭头函数没有 arguments 对象。因此，如果要向箭头函数传递一些参数，则必须使用 rest parameter。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">combine</span> = (<span class="hljs-params">...args</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> args.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">prev, curr</span>) &#123;<br>    <span class="hljs-keyword">return</span> prev + <span class="hljs-string">&#x27; &#x27;</span> + curr<br>  &#125;)<br>&#125;<br><span class="hljs-comment">// const combine = (...args) =&gt; args.reduce((prev, curr) =&gt; `$&#123;prev&#125; $&#123;curr&#125;`)</span><br><br><span class="hljs-keyword">let</span> message = <span class="hljs-title function_">combine</span>(<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Rest&#x27;</span>, <span class="hljs-string">&#x27;Parameters&#x27;</span>) <span class="hljs-comment">// =&gt;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message) <span class="hljs-comment">// JavaScript Rest Parameters</span><br></code></pre></td></tr></table></figure><h2 id="JavaScript-rest-parameter-in-a-dynamic-function"><a href="#JavaScript-rest-parameter-in-a-dynamic-function" class="headerlink" title="JavaScript rest parameter in a dynamic function"></a>JavaScript rest parameter in a dynamic function</h2><p>JavaScript 可以通过 Function 构造函数创建动态函数。并且可以在动态函数中使用 rest parameter。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> showNumbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&#x27;...numbers&#x27;</span>, <span class="hljs-string">&#x27;console.log(numbers)&#x27;</span>)<br><span class="hljs-title function_">showNumbers</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// [ 1, 2, 3 ]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES 6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6 Destructuring</title>
    <link href="/2024/03/06/ES6-Destructuring/"/>
    <url>/2024/03/06/ES6-Destructuring/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>ES6 提供了一个称为解构赋值的新功能，将对象的属性或数组的元素解构为单独的变量。</p><h2 id="ES-5-old-school-style"><a href="#ES-5-old-school-style" class="headerlink" title="ES 5 old-school style"></a>ES 5 old-school style</h2><p>在 ES 5 及以前，要想将数组的元素或对象的属性赋值给单独的变量需要使用以下语法：</p><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> scores = [<span class="hljs-number">70</span>, <span class="hljs-number">80</span>, <span class="hljs-number">90</span>]<br><span class="hljs-keyword">let</span> x = scores[<span class="hljs-number">0</span>],<br>  y = scores[<span class="hljs-number">1</span>],<br>  z = scores[<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;stein&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>,<br>&#125;<br><br><span class="hljs-keyword">let</span> name = user.<span class="hljs-property">name</span><br><span class="hljs-keyword">let</span> age = user.<span class="hljs-property">age</span><br></code></pre></td></tr></table></figure><h2 id="Array-Destructuring"><a href="#Array-Destructuring" class="headerlink" title="Array Destructuring"></a>Array Destructuring</h2><p>从 ES 6 开始，可以使用如下的语法进行数组解构赋值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> scores = [<span class="hljs-number">70</span>, <span class="hljs-number">80</span>, <span class="hljs-number">90</span>]<br><span class="hljs-keyword">let</span> [x, y, z] = scores<br></code></pre></td></tr></table></figure><p>如果 <code>scores</code> 数组只有两个值，那么变量 <code>z</code> 将会被赋值为 <code>undefined</code>，如果 <code>scores</code> 数组的元素长度大于 3，那么多余的元素将会被丢弃。</p><h3 id="Array-Destructuring-Assignment-and-Rest-syntax"><a href="#Array-Destructuring-Assignment-and-Rest-syntax" class="headerlink" title="Array Destructuring Assignment and Rest syntax"></a>Array Destructuring Assignment and Rest syntax</h3><p>可以使用 rest parameter (…) 将数组的所有剩余元素全部添加到一个新的数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> scores = [<span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>, <span class="hljs-number">90</span>, <span class="hljs-number">100</span>]<br><span class="hljs-keyword">let</span> [x, y, ...rest] = scores<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rest) <span class="hljs-comment">// [ 80, 90, 100 ]</span><br></code></pre></td></tr></table></figure><h3 id="Setting-default-values"><a href="#Setting-default-values" class="headerlink" title="Setting default values"></a>Setting default values</h3><p>如果不想给变量设置为 <code>undefined</code>，那么可以使用如下语法为解构数组对应的变量设置默认值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> scores = [<span class="hljs-number">60</span>, <span class="hljs-number">70</span>]<br><span class="hljs-keyword">let</span> [x, y, z = <span class="hljs-number">80</span>] = scores<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(z) <span class="hljs-comment">// 80</span><br></code></pre></td></tr></table></figure><h3 id="Nested-array-destructuring"><a href="#Nested-array-destructuring" class="headerlink" title="Nested array destructuring"></a>Nested array destructuring</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> nestedArr = [<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;Doe&#x27;</span>, [<span class="hljs-string">&#x27;Red&#x27;</span>, <span class="hljs-string">&#x27;Green&#x27;</span>, <span class="hljs-string">&#x27;Blue&#x27;</span>]<br><br><span class="hljs-keyword">let</span> [firstName, lastName, [red, green, blue]] = nestedArr<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstName, lastName, red, green, blue) <span class="hljs-comment">// John Doe Red Green Blue</span><br></code></pre></td></tr></table></figure><h2 id="Object-Destructuring"><a href="#Object-Destructuring" class="headerlink" title="Object Destructuring"></a>Object Destructuring</h2><p>ES6 引入了对象解构语法，提供了另一种将对象属性分配给变量的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Stein&#x27;</span>,<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Albert&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">firstName</span>: fName, <span class="hljs-attr">lastName</span>: lName &#125; = user<br></code></pre></td></tr></table></figure><p>firstName 和 lastName 属性分别分配给 fname 和 lname 变量。冒号（:）之前的标识符是对象的属性，冒号之后的标识符是变量。</p><p>如果变量与对象的属性具有相同的名称，则可以使代码更加简洁，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; firstName, lastName &#125; = user<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstName) <span class="hljs-comment">// &#x27;Stein&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lastName) <span class="hljs-comment">// &#x27;Albert&#x27;</span><br></code></pre></td></tr></table></figure><p>当对象的属性不存在时，可以为变量分配默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Doe&#x27;</span>,<br>  <span class="hljs-attr">currentAge</span>: <span class="hljs-number">28</span>,<br>&#125;<br><br><span class="hljs-keyword">let</span> &#123; firstName, lastName, middleName = <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">currentAge</span>: age = <span class="hljs-number">18</span> &#125; = person<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(middleName) <span class="hljs-comment">// &#x27;&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age) <span class="hljs-comment">// 28</span><br></code></pre></td></tr></table></figure><h3 id="Nested-object-destructuring"><a href="#Nested-object-destructuring" class="headerlink" title="Nested object destructuring"></a>Nested object destructuring</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> employee = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">1001</span>,<br>  <span class="hljs-attr">name</span>: &#123;<br>    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>    <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Doe&#x27;</span>,<br>  &#125;,<br>&#125;<br><br><span class="hljs-keyword">let</span> &#123;<br>  <span class="hljs-attr">name</span>: &#123; <span class="hljs-attr">firstName</span>: f, <span class="hljs-attr">lastName</span>: l &#125;,<br>&#125; = employee<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f) <span class="hljs-comment">// John</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(l) <span class="hljs-comment">// Doe</span><br></code></pre></td></tr></table></figure><h3 id="Destructuring-function-arguments"><a href="#Destructuring-function-arguments" class="headerlink" title="Destructuring function arguments"></a>Destructuring function arguments</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">display</span> = (<span class="hljs-params">&#123; firstName, lastName &#125;</span>) =&gt;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;firstName&#125;</span> <span class="hljs-subst">$&#123;lastName&#125;</span>`</span>)<br><span class="hljs-keyword">let</span> person = &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Doe&#x27;</span>,<br>&#125;<br><span class="hljs-title function_">display</span>(person)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES 6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Generics</title>
    <link href="/2024/03/05/Java-Generics/"/>
    <url>/2024/03/05/Java-Generics/</url>
    
    <content type="html"><![CDATA[<ol><li><a href="https://stein283036.github.io/2024/03/18/Why-Use-Generics/">Why Use Generics?</a></li><li><a href="https://stein283036.github.io/2024/03/18/Generic-Types/">Generic Types</a></li><li><a href="https://stein283036.github.io/2024/03/18/Generic-Methods/">Generic Methods</a></li><li><a href="https://stein283036.github.io/2024/03/18/Bounded-Type-Parameters/">Bounded Type Parameters</a></li><li><a href="https://stein283036.github.io/2024/03/18/Generics-Inheritance-and-Subtypes/">Generics, Inheritance, and Subtypes</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java Generics</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
